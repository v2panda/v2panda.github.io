<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>v2panda&#39;s blog</title>
  <subtitle>subtitle</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://v2panda.com/"/>
  <updated>2017-02-23T14:16:01.000Z</updated>
  <id>http://v2panda.com/</id>
  
  <author>
    <name>熊猫</name>
    <email>pdxuzhen@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>更换网络调试工具 - Vlutr</title>
    <link href="http://v2panda.com/2016/12/25/vlutr/"/>
    <id>http://v2panda.com/2016/12/25/vlutr/</id>
    <published>2016-12-25T07:10:51.000Z</published>
    <updated>2017-02-23T14:16:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>一年多前部署在 DigitalOcean 的<a href="http://v2panda.com/2015/11/25/network-debugging-tools/">梯子</a>越来越不稳定了，速度也越来越慢，让人难以忍受，所以决定换一个，迁移到 Vlutr 上来。本文作为记录，也供想搭小梯子的朋友们参考。</p>
<p>PS：有想使用 Vlutr 的朋友可以通过我的<a href="http://www.vultr.com/?ref=7115351-3B" target="_blank" rel="external">邀请链接</a>注册，可以得到额外的20$。</p>
<a id="more"></a>
<h1 id="大体流程">大体流程</h1><h3 id="1-注册并绑定_PayPal">1.注册并绑定 PayPal</h3><p><img src="http://7xnmlk.com1.z0.glb.clouddn.com/v-paypal.png" alt=""></p>
<h3 id="2-选择服务器">2.选择服务器</h3><p><img src="http://7xnmlk.com1.z0.glb.clouddn.com/v-chooseServer.png" alt=""></p>
<h3 id="3-安装_SS">3.安装 SS</h3><p>安装主要是三个命令:</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --<span class="keyword">no</span>-check-certificate http<span class="variable">s:</span>//raw.githubusercontent.<span class="keyword">com</span>/teddysun/shadowsocks_install/master/shadowsocksR.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">chmod</span> +<span class="tag">x</span> <span class="tag">shadowsocksR</span><span class="class">.sh</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./shadowsocksR.sh <span class="number">2</span>&gt;&amp;<span class="number">1</span> | tee shadowsockssR.<span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<p>密码和端口自己设置，后期想修改可以编辑配置文件</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi <span class="regexp">/etc/</span>shadowsocks.json</span><br></pre></td></tr></table></figure>
<p>其它相关命令：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/etc/</span>init.d<span class="regexp">/shadowsocks status /</span>/检测状态</span><br><span class="line"><span class="regexp">/etc/</span>init.d<span class="regexp">/shadowsocks stop   /</span>/ 关闭服务</span><br><span class="line"><span class="regexp">/etc/</span>init.d<span class="regexp">/shadowsocks start  /</span>/启动服务</span><br></pre></td></tr></table></figure>
<h3 id="4-配置锐速">4.配置锐速</h3><p>锐速的一键脚本，可以提升连接速度，开了后 100M 的网速表现为流畅观看Youtube 8K，无暂停，晚高峰时段，服务器平均 ping 值约 80。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -<span class="keyword">N</span> --<span class="keyword">no</span>-check-certificate http<span class="variable">s:</span>//raw.githubusercontent.<span class="keyword">com</span>/<span class="number">91</span>yun/serverspeeder/master/serverspeeder-<span class="keyword">all</span>.<span class="keyword">sh</span> &amp;&amp; bash serverspeeder-<span class="keyword">all</span>.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure>
<p>装完之后自动会运行， 下面是检测锐速的命令</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/serverspeeder/bin/serverSpeeder<span class="class">.sh</span> status <span class="comment">// 状态</span></span><br><span class="line">/serverspeeder/bin/serverSpeeder<span class="class">.sh</span> restart<span class="comment">// 重启</span></span><br></pre></td></tr></table></figure>
<h1 id="最后">最后</h1><p>全都搞定后，配合 Surge 和 Surge for Mac 简直爽歪歪，比以前 DigitalOcean 的强太多，有需要的朋友赶紧去试试吧~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;&lt;p&gt;一年多前部署在 DigitalOcean 的&lt;a href=&quot;http://v2panda.com/2015/11/25/network-debugging-tools/&quot;&gt;梯子&lt;/a&gt;越来越不稳定了，速度也越来越慢，让人难以忍受，所以决定换一个，迁移到 Vlutr 上来。本文作为记录，也供想搭小梯子的朋友们参考。&lt;/p&gt;
&lt;p&gt;PS：有想使用 Vlutr 的朋友可以通过我的&lt;a href=&quot;http://www.vultr.com/?ref=7115351-3B&quot;&gt;邀请链接&lt;/a&gt;注册，可以得到额外的20$。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Shadowsocks" scheme="http://v2panda.com/tags/Shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>自实现 KVO</title>
    <link href="http://v2panda.com/2016/11/29/custom-kvo/"/>
    <id>http://v2panda.com/2016/11/29/custom-kvo/</id>
    <published>2016-11-29T13:49:12.000Z</published>
    <updated>2016-12-01T08:44:55.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本概念">基本概念</h3><p>KVO (Key-Value Observing) 是Cocoa提供的一种基于KVC的机制，允许一个对象去监听另一个对象的某个属性，当该属性改变时系统会去通知监听的对象。</p>
<a id="more"></a>
<p>添加方法：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="typename">void</span>)<span class="string">addObserver:</span>(NSObject *)observer <span class="string">forKeyPath:</span>(NSString *)keyPath <span class="string">options:</span>(NSKeyValueObservingOptions)opions <span class="string">context:</span>(nullable <span class="typename">void</span> *)context;</span><br></pre></td></tr></table></figure>
<p>接收方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(nullable <span class="built_in">NSString</span> *)keyPath ofObject:(nullable <span class="keyword">id</span>)object change:(nullable <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>, <span class="keyword">id</span>&gt; *)change context:(nullable <span class="keyword">void</span> *)context;</span><br></pre></td></tr></table></figure>
<p>移除方法：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="typename">void</span>)<span class="string">removeObserver:</span>(NSObject *)observer <span class="string">forKeyPath:</span>(NSString *)keyPath <span class="string">context:</span>(nullable <span class="typename">void</span> *)context</span><br><span class="line">或者</span><br><span class="line">- (<span class="typename">void</span>)<span class="string">removeObserver:</span>(NSObject *)observer <span class="string">forKeyPath:</span>(NSString *)keyPath;</span><br></pre></td></tr></table></figure>
<p>本文相关 <a href="https://github.com/v2panda/PDPractice/tree/master/Demo_KVO" target="_blank" rel="external">Demo</a></p>
<h3 id="自动_KVO">自动 KVO</h3><p>调用上面三个方法实现即自动 KVO，不细说。</p>
<h3 id="手动_KVO">手动 KVO</h3><p>以 Demo 中的 Boy 类为例，Boy 有 <code>name</code> 和 <code>age</code> 两个属性，要实现手动发送 KVO 得先禁用 KVO 的自动发送机制，再在需要发送的地方手动发送。</p>
<p>1.在 Boy 类中重写以下方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> *  重写此方法，设置对该 key 不自动发送通知</span><br><span class="line"> */</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>) automaticallyNotifiesObserversForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"name"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"age"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> automaticallyNotifiesObserversForKey:key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.手动发送 KVO</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> *  手动发送通知</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="typename">void</span>)<span class="string">setName:</span>(NSString *)name &#123;</span><br><span class="line">    <span class="keyword">if</span> (_name != name) &#123;</span><br><span class="line">        [self <span class="string">willChangeValueForKey:</span>@<span class="string">"name"</span>];</span><br><span class="line">        _name = name;</span><br><span class="line">        [self <span class="string">didChangeValueForKey:</span>@<span class="string">"name"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="typename">void</span>)<span class="string">setAge:</span>(<span class="typename">int</span>)age &#123;</span><br><span class="line">    <span class="keyword">if</span> (_age != age) &#123;</span><br><span class="line">        [self <span class="string">willChangeValueForKey:</span>@<span class="string">"age"</span>];</span><br><span class="line">        _age = age;</span><br><span class="line">        [self <span class="string">didChangeValueForKey:</span>@<span class="string">"age"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="KVO_注册依赖键">KVO 注册依赖键</h3><p>有一些属性的值取决于一个或者多个其他对象的属性值，一旦某个被依赖的属性值变了，依赖它的属性的变化也需要被通知。</p>
<h4 id="To-one_依赖键">To-one 依赖键</h4><p>以 Demo 中的 Person 类为例，其 <code>information</code> 属性同时依赖 <code>name</code> 和 <code>age</code> 属性：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span>  依赖键 information 依赖 name 和 age</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">- (NSString <span class="keyword">*</span>)information &#123;</span><br><span class="line">    return [NSString stringWithFormat:<span class="comment">@"%@-%d",_name,_age];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话修改 <code>name</code> 和 <code>age</code> 都会改变 <code>information</code> 的值，此时想实现对 <code>information</code> 的 KVO，需要重新确认依赖关系，这里有两种方法。</p>
<p>1.实现<code>+ (NSSet *)keyPathsForValuesAffecting&lt;Key&gt;:(NSString *)key</code></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSSet</span> *)keyPathsForValuesAffectingInformation &#123;</span><br><span class="line">    <span class="built_in">NSSet</span> * keyPaths = [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@"age"</span>, <span class="string">@"name"</span>, <span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">return</span> keyPaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.重写<code>+ (NSSet *)keyPathsForValuesAffectingValueForKey:(NSString *)key</code></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (NSSet *)<span class="string">keyPathsForValuesAffectingValueForKey:</span>(NSString *)key &#123;</span><br><span class="line">    NSSet *keyPaths = [<span class="keyword">super</span> <span class="string">keyPathsForValuesAffectingValueForKey:</span>key];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([key <span class="string">isEqualToString:</span>@<span class="string">"information"</span>]) &#123;</span><br><span class="line">        keyPaths = [keyPaths <span class="string">setByAddingObjectsFromArray:</span>@[@<span class="string">"name"</span>, @<span class="string">"age"</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> keyPaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="To-many_依赖键">To-many 依赖键</h4><p>以 Demo 中的 Person 类为例，其 <code>totalAges</code> 属性依赖 <code>girls</code> 这个集合属性，<code>totalAges</code>的值为<code>girls</code>数组里所有<code>Girl</code>对象的 <code>age</code> 之和。<br>那么为实现对<code>totalAges</code>的 KVO，需要在 Person 类里监听 <code>girls</code> 属性，然后每次更新<code>totalAges</code>的值：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"girls"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span>|<span class="built_in">NSKeyValueObservingOptionOld</span> context:totalAgesContext];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="keyword">if</span> (context == totalAgesContext) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"totalAgesContext:%@,%@"</span>,change[<span class="string">@"new"</span>],change[<span class="string">@"old"</span>]);</span><br><span class="line">        [<span class="keyword">self</span> updateTotalAges];</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Any unrecognized context must belong to super</span></span><br><span class="line">        [<span class="keyword">super</span> observeValueForKeyPath:keyPath</span><br><span class="line">                             ofObject:object</span><br><span class="line">                               change:change</span><br><span class="line">                              context:context];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)updateTotalAges &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *sum = (<span class="built_in">NSString</span> *)[<span class="keyword">self</span> valueForKeyPath:<span class="string">@"girls.@sum.age"</span>];</span><br><span class="line">    [<span class="keyword">self</span> setTotalAges:sum<span class="variable">.intValue</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="KVO_原理">KVO 原理</h3><p>先来看看苹果怎么说</p>
<blockquote>
<p>Key-Value Observing Implementation Details</p>
<p>Automatic key-value observing is implemented using a technique called <strong>isa-swizzling</strong>.</p>
<p>The isa pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.</p>
<p>When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.</p>
<p>You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.</p>
</blockquote>
<p>可见苹果是实现了一种叫 <strong>isa-swizzling</strong> 的机制，那么具体怎么做呢，大概有这么几步：</p>
<ul>
<li><p>1.在运行期动态地创建被观察类的派生类（类名就是在该类的前面加上NSKVONotifying_ 前缀）</p>
</li>
<li><p>2.在这个派生类中重写基类中被观察属性的 setter 方法</p>
</li>
<li><p>3.将 isa 指向这个新建的派生类(欺骗外部调用者它就是起初的那个类)</p>
</li>
</ul>
<p>注意这里是在派生类里被重写的 setter 方法里实现真正的通知机制，在对象上对 setter 的调用就会调用重写的 setter，从而激活 KVO。</p>
<h3 id="自实现_KVO">自实现 KVO</h3><p>根据上面的原理，来自实现一个 KVO 机制，首先创建一个 <code>NSObject</code> 的分类:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^PDObservingBlock)(<span class="keyword">id</span> observedObject, <span class="built_in">NSString</span> *observedKey, <span class="keyword">id</span> oldValue, <span class="keyword">id</span> newValue);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">PDKVO</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)pd_addObserver:(<span class="built_in">NSObject</span> *)observer</span><br><span class="line">                forKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">             withBlock:(PDObservingBlock)block;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)pd_removeObserver:(<span class="built_in">NSObject</span> *)observer forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="ObservationInfo">ObservationInfo</h4><p>添加对 block 的支持，block info 如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PDObservationInfo</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSObject</span> *observer;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *key;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) PDObservingBlock block;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PDObservationInfo</span></span></span><br><span class="line"></span><br><span class="line">- (instancetype)initWithObserver:(<span class="built_in">NSObject</span> *)observer</span><br><span class="line">                             Key:(<span class="built_in">NSString</span> *)key</span><br><span class="line">                           block:(PDObservingBlock)block &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _observer = observer;</span><br><span class="line">        _key = key;</span><br><span class="line">        _block = block;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="addObserver">addObserver</h4><p>在 <code>addObserver</code> 方法里首先得检查对象是否存在该属性的setter方法，若没有则抛出异常：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SEL setterSelector = NSSelectorFromString(setterForGetter(key));</span><br><span class="line"><span class="function"><span class="keyword">Method</span> <span class="title">setterMethod</span> = <span class="title">class_getInstanceMethod</span><span class="params">([<span class="keyword">self</span> <span class="keyword">class</span>], setterSelector)</span>;</span></span><br><span class="line"><span class="keyword">if</span> (!setterMethod) <span class="comment">&#123;</span><br><span class="line">    NSString *reason = [NSString stringWithFormat:@"Object %@ does not have a setter for key %@", self, key];</span><br><span class="line">    @throw [NSException exceptionWithName:NSInvalidArgumentException</span><br><span class="line">                                   reason:reason</span><br><span class="line">                                 userInfo:nil];</span><br><span class="line">    return;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>然后检查自身(类)是否是 KVO 类，如果不是，新建一个继承原来类的子类，并把 isa 指向这个新建的子类：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = object_getClass(<span class="keyword">self</span>);</span><br><span class="line"><span class="built_in">NSString</span> *clazzName = <span class="built_in">NSStringFromClass</span>(clazz);</span><br><span class="line"><span class="keyword">if</span> (![clazzName hasPrefix:kPDKVOClassPrefix]) &#123;</span><br><span class="line">    clazz = [<span class="keyword">self</span> createKvoClassWithOriginalClassName:clazzName];</span><br><span class="line">    <span class="comment">// 改变 isa 指向刚创建的 clazz 类</span></span><br><span class="line">    object_setClass(<span class="keyword">self</span>, clazz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再添加重写的 setter 方法，并将 block 信息加到数组中：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (![<span class="keyword">self</span> hasSelector:setterSelector]) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *types = method_getTypeEncoding(setterMethod);</span><br><span class="line">    class_addMethod(clazz, setterSelector, (IMP)kvo_setter, types);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建观察者的信息</span></span><br><span class="line">PDObservationInfo *info = [[PDObservationInfo alloc] initWithObserver:observer Key:key block:block];</span><br><span class="line"></span><br><span class="line"><span class="keyword">@synchronized</span> (info) &#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *observers = objc_getAssociatedObject(<span class="keyword">self</span>, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(kPDKVOAssociatedObservers));</span><br><span class="line">    <span class="keyword">if</span> (!observers) &#123;</span><br><span class="line">        observers = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(kPDKVOAssociatedObservers), observers, OBJC_ASSO<span class="built_in">CIATION_RETAIN_NONATOMIC</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    [observers addObject:info];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是这里 <code>@synchronized()</code> 传入的是 info 而不是 self，这是因为 synchronized 中传入的 object 的内存地址，被用作 key，通过hash map对应的一个系统维护的递归锁。所以不管是传入什么类型的object，只要是有内存地址，就能启动同步代码块的效果。因此避免传入 self，以免导致死锁，例如：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class A</span></span><br><span class="line"><span class="at_rule">@synchronized (self) &#123;</span></span><br><span class="line">    <span class="attr_selector">[_sharedLock lock]</span>;</span><br><span class="line">    <span class="function">NSLog</span>(<span class="at_rule">@<span class="string">"code in class A"</span>);</span></span><br><span class="line">    <span class="attr_selector">[_sharedLock unlock]</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class B</span></span><br><span class="line"><span class="attr_selector">[_sharedLock lock]</span>;</span><br><span class="line"><span class="at_rule">@synchronized (objectA) &#123;</span></span><br><span class="line">    <span class="function">NSLog</span>(<span class="at_rule">@<span class="string">"code in class B"</span>);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="attr_selector">[_sharedLock unlock]</span>;</span><br></pre></td></tr></table></figure>
<p>原因是因为self很可能会被外部对象访问，被用作key来生成一锁，类似上述代码中的@synchronized (objectA)。两个公共锁交替使用的场景就容易出现死锁。</p>
<p>所以正确的做法是传入一个类内部维护的NSObject对象，而且这个对象是对外不可见的。</p>
<h4 id="调用">调用</h4><p>一句代码就搞定，不用再到<code>- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context</code>方法里去嵌套 <code>if else</code></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span><span class="variable">.message</span> pd_addObserver:<span class="keyword">self</span> forKey:<span class="string">@"info"</span> withBlock:^(<span class="keyword">id</span> observedObject, <span class="built_in">NSString</span> *observedKey, <span class="keyword">id</span> oldValue, <span class="keyword">id</span> newValue) &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.label</span><span class="variable">.text</span> = newValue;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>具体实现可见 <a href="https://github.com/v2panda/PDPractice/tree/master/Demo_KVO" target="_blank" rel="external">Demo</a> 的 <code>NSObject+PDKVO</code> 类。</p>
<h3 id="Reference">Reference</h3><p><a href="http://tech.glowing.com/cn/implement-kvo/" target="_blank" rel="external">如何自己动手实现 KVO</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本概念&quot;&gt;基本概念&lt;/h3&gt;&lt;p&gt;KVO (Key-Value Observing) 是Cocoa提供的一种基于KVC的机制，允许一个对象去监听另一个对象的某个属性，当该属性改变时系统会去通知监听的对象。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基于 MVC 的项目重构</title>
    <link href="http://v2panda.com/2016/10/31/mvc-reconsitution/"/>
    <id>http://v2panda.com/2016/10/31/mvc-reconsitution/</id>
    <published>2016-10-31T14:43:00.000Z</published>
    <updated>2016-12-22T12:04:16.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>最近公司的项目要更新所有界面的 UI 风格，趁此机会正好把项目重构一遍，本文主要记录重构时的一些选择和解决的问题。</p>
<a id="more"></a>
<h3 id="背景">背景</h3><p>首先说说背景，也就是为什么要重构，因为重构是需要成本的，一不小心修改错了，就会让原来完好的产品出各种问题，所以先总结下为什么，主要是以下四个问题：</p>
<ul>
<li>1.没有统一的代码风格<br>这个就比较痛苦了，因为历史的原因，或者说这个项目初期就没有代码规范，在接手项目前，代码风格就非常随意、天马行空。在此期间我重构了一部分，但仍有一大半不规范的代码。</li>
<li>2.臃肿的 ViewController<br>这个好理解，一个类几千行代码，应该的不应该的都挤在一起。</li>
<li>3.难以理解的逻辑代码<br>业务逻辑代码混乱不堪，看的头疼，还不敢乱删。</li>
<li>4.混乱的类调用<br>没有明确一个类该做什么，全都堆在一起。</li>
</ul>
<p>追求代码质量是一个优秀程序员对自己的要求，所以趁这个机会，决定把整个项目重构一遍。</p>
<h3 id="架构的选择">架构的选择</h3><p>当前在 iOS 开发上有很多热门的架构模式，如 MVC、MVVM、MVCS、VIPER 等等。对此我的观点是：架构的选择要结合具体的情况，比如业务的复杂度、开发人员的接受程度，以及重构的时间周期等等，选择一个对的架构比选择一个复杂的架构更为重要。<br>在老项目里选择的是 MVC，对于项目中的绝大部分场景来说，MVC 没有成为制约业务发展的瓶颈，同时考虑到新项目的学习成本以及重构时间周期的问题，所以在新项目上还是选择了 MVC。</p>
<h3 id="统一的代码风格">统一的代码风格</h3><p>无规矩不成方圆，在老项目里由于流程的缺失和开发人员的更迭，一直没有一个统一的编码规范。而在多人开发时，保持统一的编码规范是很有必要的，这样易于保持代码一致性和 Code Review。所以确定了架构之后，接着就是确定编码规范。<br>下面是编码规范里一些需要注意的点：</p>
<h4 id="命名">命名</h4><p>使用可读的驼峰命名法去给类、方法、变量命名。<br>常量应该使用驼峰式命名规则，所有的单词首字母大写和加上与类名有关的前缀。</p>
<h4 id="代码分块">代码分块</h4><p>在函数分组和protocol/delegate实现中使用#pragma mark -来分类方法，要遵循以下一般结构：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="id">#pragma</span> <span class="tag">mark</span> <span class="tag">-</span> <span class="tag">Lifecycle</span></span><br><span class="line"></span><br><span class="line"><span class="tag">-</span> (instancetype)<span class="tag">init</span> &#123;&#125;</span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">dealloc</span> &#123;&#125;</span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">viewDidLoad</span> &#123;&#125;</span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">viewWillAppear</span>:(BOOL)<span class="tag">animated</span> &#123;&#125;</span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">didReceiveMemoryWarning</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="id">#pragma</span> <span class="tag">mark</span> <span class="tag">-</span> <span class="tag">Custom</span> <span class="tag">Accessors</span></span><br><span class="line"></span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">setCustomProperty</span>:(id)<span class="tag">value</span> &#123;&#125;</span><br><span class="line"><span class="tag">-</span> (id)<span class="tag">customProperty</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="id">#pragma</span> <span class="tag">mark</span> <span class="tag">-</span> <span class="tag">IBActions</span></span><br><span class="line"></span><br><span class="line"><span class="tag">-</span> (IBAction)<span class="tag">submitData</span>:(id)<span class="tag">sender</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="id">#pragma</span> <span class="tag">mark</span> <span class="tag">-</span> <span class="tag">Public</span></span><br><span class="line"></span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">publicMethod</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="id">#pragma</span> <span class="tag">mark</span> <span class="tag">-</span> <span class="tag">Private</span></span><br><span class="line"></span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">privateMethod</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="id">#pragma</span> <span class="tag">mark</span> <span class="tag">-</span> <span class="tag">Protocol</span> <span class="tag">conformance</span></span><br></pre></td></tr></table></figure>
<h4 id="留空白">留空白</h4><ul>
<li>建议使用tabs 而不是使用空格,tabs缩进使用4个空格，确保在Xcode偏好设置来设置。</li>
<li>文件结束时留一行空白</li>
<li>用足够的空行把代码分割为合理的逻辑块，而不是非常紧凑</li>
<li>不要在一行代码结尾处留空格</li>
<li>更不要在空行（\n）中使用缩进（\t）</li>
</ul>
<h4 id="代码块缩进">代码块缩进</h4><p>(if/else/switch/while etc.)或者method function 的大括号留在当前行，并前保留一个空格 ，能省略的不要添加<br>如</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> user.isHappy &#123;</span><br><span class="line">  // <span class="keyword">Do</span> something</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  // <span class="keyword">Do</span> something <span class="keyword">else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不推荐</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (user.isHappy )          多余空格</span><br><span class="line">&#123;                  换行位置不对</span><br><span class="line">  // <span class="keyword">Do</span> something</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  // <span class="keyword">Do</span> something <span class="keyword">else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="项目层级划分">项目层级划分</h3><h4 id="物理层级">物理层级</h4><p>上文确认了项目架构是以 MVC 为主，所以这里推荐使用 MVC + 按业务划分项目层级的方式。具体的如下图：</p>
<p><img src="http://7xnmlk.com1.z0.glb.clouddn.com/mvc1.png" alt=""></p>
<p>整个项目主要分为4个文件夹，分别是：</p>
<ul>
<li>AppDelegate: 程序入口。</li>
<li>Classes: 存放主要代码文件。</li>
<li>Resources: 存放资源文件，如图片、音频、视频、 HTML 文件等。</li>
<li>Supporting Files: 存放配置文件，如 Info.plist、main.m、pch 文件等。</li>
</ul>
<p>而其中 Classes 目录下，又细分如下图：</p>
<p><img src="http://7xnmlk.com1.z0.glb.clouddn.com/mvc2.png" alt=""></p>
<ul>
<li>General：存放一些通用的类，如基类、Category、Model 等。</li>
<li>Sections：按业务模块细分 MVC。</li>
<li>Helpers：存放各种工具类。</li>
<li>Venders：存放需要手动引入的第三方库。</li>
<li>Macro：存放全局头文件，各种宏定义，常量等。</li>
</ul>
<h4 id="代码逻辑层级">代码逻辑层级</h4><p>从代码逻辑上，大致分为 5 层</p>
<ul>
<li>网络层：负责和服务器通讯获取数据。</li>
<li>数据层：存储用户的数据，包括内存cache。</li>
<li>业务层：包含各种业务逻辑。</li>
<li>UI数据层：负责提供UI层所需要的数据，UI只和这层打交道。</li>
<li>UI层：包括ViewController和View，处理用户的输入。</li>
</ul>
<p>分层使项目更清晰，开发时做到各个层独立，高内聚、低耦合。</p>
<h3 id="布局规范">布局规范</h3><h4 id="AutoLayout">AutoLayout</h4><p>老项目是纯 Frame 布局，代码里有一大堆 Magic Number，一大堆屏幕尺寸判断，而这些造成了项目里有过多的布局代码，对于刚上手项目的人来说也不太容易看懂。所以这次重构整体采用 AutoLayout 布局，摒弃老项目里的纯 Frame 布局方式，精简代码。</p>
<h4 id="Xib/Storyboard">Xib/Storyboard</h4><p>手写 UI 和 Xib/Storyboard 谁优谁劣这里不做讨论，但有一点我认为 Xib/Storyboard 是比手写 UI 要快的。而这次重构工作量大工期紧，所以摒弃老项目里的手写 UI ，改用 Xib/Storyboard 。</p>
<h3 id="精简_ViewController">精简 ViewController</h3><p>这一部分我认为是本次重构的重头戏，也是本次重构的主要目的所在，精简 ViewController 里的代码，解决老项目中 Massive ViewController 的问题。<br>主要工作分为以下几步：</p>
<ul>
<li>1.保留最重要的任务，拆分其它不重要的任务。</li>
<li>2.拆分后的模块要尽可能提高可复用性，尽量做到DRY</li>
<li>3.提高拆分模块后的抽象度</li>
</ul>
<h3 id="胖_Model_的问题">胖 Model 的问题</h3><p>上文精简 ViewController 把代码都加入到 Model 里去，所以会造成胖 Model 的问题。对此我的理解是，除了优化外，代码的总量是确定的，一方的精简必然会造成一方的增加，而 Model 在这里是用来帮 ViewController 处理业务逻辑的，也就是说胖 Model 包含了部分弱业务逻辑。胖 Model 要达到的目的是，Controller从胖 Model 这里拿到数据之后，不用额外做操作或者只要做非常少的操作，就能够将数据直接应用在 View 上，从这点上看胖 Model 也是可以接受的。</p>
<h3 id="单元测试">单元测试</h3><p>老项目是不写测试代码的，也没有写单元测试的条件。想想一个类堆砌几千行代码，想写也不好下手，但既然重构了，单元测试也得补上。</p>
<p>单元测试对于目前来说，就是为了方便测试一些功能是否正常运行，还有调试接口是否能正常使用。</p>
<p>有时候你可能是为了测试某一个网络接口，然后每次都重新启动并且经过很多操作之后才测试到了那个网络接口，如果使用了单元测试，就可以直接测试那个方法，相对方便很多。<br>比如由于修改较多，想测试一下分享功能是否正常，这时候就有用了。或者直接看一些接口返回的数据也会非常直观，不用启动整个工程。</p>
<h3 id="TODO">TODO</h3><p>在这也列举两个接下来可以做的事，先添加到 ToDoList 里。</p>
<ul>
<li><p>URLRoute</p>
</li>
<li><p>模块化</p>
</li>
</ul>
<h3 id="最后">最后</h3><p>其实总结起来就三点，尽量保证：</p>
<ul>
<li>Controller 里的代码尽可能的少</li>
<li>Model 的功能尽可能的完整</li>
<li>View 尽可能独立</li>
</ul>
<p>就能构建一个容易维护，便于协同的项目。</p>
<p>本文只是在项目重构中总结的一些比较重要的点，并不意味着都是最优解。而我在项目的架构和代码的组织上经验尚浅，若本文有什么错误或是有更好的方法请直接指出，欢迎交流讨论。</p>
<h3 id="Reference">Reference</h3><p><a href="http://casatwy.com/iosying-yong-jia-gou-tan-viewceng-de-zu-zhi-he-diao-yong-fang-an.html" target="_blank" rel="external">iOS应用架构谈 view层的组织和调用方案</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;&lt;p&gt;最近公司的项目要更新所有界面的 UI 风格，趁此机会正好把项目重构一遍，本文主要记录重构时的一些选择和解决的问题。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AFNetworking 源码阅读笔记（三）</title>
    <link href="http://v2panda.com/2016/09/30/afnetworking-3/"/>
    <id>http://v2panda.com/2016/09/30/afnetworking-3/</id>
    <published>2016-09-30T11:52:43.000Z</published>
    <updated>2016-09-30T11:54:10.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xnmlk.com1.z0.glb.clouddn.com/afnetworking-logo.png" alt="AFNetworking"><br><a href="https://github.com/AFNetworking/AFNetworking/" target="_blank" rel="external">AFNetworking</a> 是 Objective-C 中用于网络请求的第三方框架，我们一般使用它来封装网络请求，这篇文章记录了阅读 AFNetworking(Version 3.1.0) 源码的笔记，简单的研究了它的实现细节。</p>
<a id="more"></a>
<h3 id="AFURLRequestSerialization">AFURLRequestSerialization</h3><p>AFURLRequestSerialization 只是个协议，其内部提供了一个方法用以序列化请求数据。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AFURLRequestSerialization</span> &lt;<span class="title">NSObject</span>, <span class="title">NSSecureCoding</span>, <span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (nullable <span class="built_in">NSURLRequest</span> *)requestBySerializingRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                               withParameters:(nullable <span class="keyword">id</span>)parameters</span><br><span class="line">                                        error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error <span class="built_in">NS_SWIFT_NOTHROW</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>同时也要遵循 NSObject、NSSecureCoding 和 NSCopying 这三个协议，实现安全编码、拷贝等。</p>
<p>在 AFNetworking 内部里遵循这个协议并返回特定的数据类型有 3 种，分别是：</p>
<ul>
<li>AFHTTPRequestSerializer</li>
<li>AFJSONRequestSerializer</li>
<li>AFPropertyListRequestSerializer</li>
</ul>
<p>一般来说请求都会按 key=value 的方式带上各种参数，GET 方法参数会直接加在 URL 上，POST 方法放在 body 上，而 NSURLRequest 没有直接对这个参数的解析，所以都是拼好字符串再往上添加的。但 AFURLRequestSerialization 提供了接口，让参数可以是 NSDictionary, NSArray, NSSet 这些类型，再由内部解析成字符串后赋给 NSURLRequest。因为 AFHTTPRequestSerializer 为 AFHTTPSessionManager 创建时默认的 requestSerializer，下面具体过程以 AFHTTPRequestSerializer 的相关方法为例。</p>
<h4 id="requestWithMethod_方法">requestWithMethod 方法</h4><p><code>requestWithMethod:</code>方法是 AFHTTPSessionManager 在创建 dataTask 前用来创建 request 的，方法具体实现如下：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">NSMutableURLRequest</span> *)requestWithMethod:(<span class="type">NSString</span> *)<span class="keyword">method</span></span><br><span class="line">                                 <span class="type">URLString</span>:(<span class="type">NSString</span> *)<span class="type">URLString</span></span><br><span class="line">                                parameters:(id)parameters</span><br><span class="line">                                     error:(<span class="type">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    // 进行参数断言</span><br><span class="line">    <span class="type">NSParameterAssert</span>(<span class="keyword">method</span>);</span><br><span class="line">    <span class="type">NSParameterAssert</span>(<span class="type">URLString</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">NSURL</span> *url = [<span class="type">NSURL</span> <span class="type">URLWithString</span>:<span class="type">URLString</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">NSParameterAssert</span>(url);</span><br><span class="line"></span><br><span class="line">    // 使用url构建并初始化<span class="type">NSMutableURLRequest</span>，然后设置<span class="type">HTTPMethod</span></span><br><span class="line">    <span class="type">NSMutableURLRequest</span> *mutableRequest = [[<span class="type">NSMutableURLRequest</span> alloc] initWithURL:url];</span><br><span class="line">    mutableRequest.<span class="type">HTTPMethod</span> = <span class="keyword">method</span>;</span><br><span class="line"></span><br><span class="line">    // 给<span class="type">NSMutableURLRequest</span>自带的属性赋值</span><br><span class="line">    // 然后通过判断mutableObservedChangedKeyPaths（<span class="type">NSMutableSet</span>）中是否有这个keyPath，来设定mutableRequest对应的keyPath值</span><br><span class="line">    // <span class="type">AFHTTPRequestSerializerObservedKeyPaths</span>这个数组里的属性是固定的，且在 init 方法里全都 <span class="type">KVO</span> 了</span><br><span class="line">    /**</span><br><span class="line">     *  当 <span class="type">AFHTTPRequestSerializerObserverContext</span> 中有 value 变化了(且变化后的新值不为 <span class="type">NSNull</span> null)，就会响应 observerValueForKeyPath 这个函数，从而mutableObservedChangedKeyPaths就会添加这个 keyPath</span><br><span class="line">     */</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">NSString</span> *keyPath <span class="keyword">in</span> <span class="type">AFHTTPRequestSerializerObservedKeyPaths</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([self.mutableObservedChangedKeyPaths containsObject:keyPath]) &#123;</span><br><span class="line">            [mutableRequest setValue:[self valueForKeyPath:keyPath] forKey:keyPath];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将传入的parameters进行编码，并添加到request中</span><br><span class="line">    mutableRequest = [[self requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mutableRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要是使用指定的 HTTP method 和 URLString 来构建一个 NSMutableURLRequest 对象实例，如果 method 是 <code>GET、HEAD、DELETE</code>，那么 parameter 将会被用来构建一个基于 url 编码的查询字符串，并且这个字符串会直接加到 request 的 url 后面。对于其他的Method，比如<code>POST/PUT</code>，会根据 parameterEncoding 属性进行编码，而后加到 request 的 http body 上，这里具体是调用 <code>requestBySerializingRequest:</code> 这个方法。</p>
<h4 id="requestBySerializingRequest_方法">requestBySerializingRequest 方法</h4><p><code>requestBySerializingRequest:</code> 方法做了以下事情：</p>
<ul>
<li>1.设置 HTTP 的头部</li>
<li>2.构建查询字符串</li>
<li>3.拼接参数</li>
<li>4.将 query 设置到 http body 上</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLRequest</span> *)requestBySerializingRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                               withParameters:(<span class="keyword">id</span>)parameters</span><br><span class="line">                                        error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(request);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableRequest = [request mutableCopy];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.设置request的http header field</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.HTTPRequestHeaders</span> enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span> field, <span class="keyword">id</span> value, <span class="built_in">BOOL</span> * __unused stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (![request valueForHTTPHeaderField:field]) &#123;</span><br><span class="line">            [mutableRequest setValue:value forHTTPHeaderField:field];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.构建查询字符串 query</span></span><br><span class="line">    <span class="built_in">NSString</span> *query = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (parameters) &#123;</span><br><span class="line">        <span class="comment">// 第一种，自定义了queryStringSerialization</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.queryStringSerialization</span>) &#123;</span><br><span class="line">            <span class="built_in">NSError</span> *serializationError;</span><br><span class="line">            query = <span class="keyword">self</span><span class="variable">.queryStringSerialization</span>(request, parameters, &amp;serializationError);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (serializationError) &#123;</span><br><span class="line">                <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                    *error = serializationError;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 第二种，使用AFQueryStringFromParameters() 方法</span></span><br><span class="line">            <span class="keyword">switch</span> (<span class="keyword">self</span><span class="variable">.queryStringSerializationStyle</span>) &#123;</span><br><span class="line">                <span class="keyword">case</span> AFHTTPRequestQueryStringDefaultStyle:</span><br><span class="line">                    query = AFQueryStringFromParameters(parameters);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.拼接参数</span></span><br><span class="line">    <span class="comment">// 这几个method的quey是拼接到url后面的。而POST、PUT是把query拼接到http body中的。</span></span><br><span class="line">    <span class="comment">// 判断该request中是否包含了GET、HEAD、DELETE</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span><span class="variable">.HTTPMethodsEncodingParametersInURI</span> containsObject:[[request HTTPMethod] uppercaseString]]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (query &amp;&amp; query<span class="variable">.length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 将query合并到mutbleRequest的query url 上</span></span><br><span class="line">            mutableRequest<span class="variable">.URL</span> = [<span class="built_in">NSURL</span> URLWithString:[[mutableRequest<span class="variable">.URL</span> absoluteString] stringByAppendingFormat:mutableRequest<span class="variable">.URL</span><span class="variable">.query</span> ? <span class="string">@"&amp;%@"</span> : <span class="string">@"?%@"</span>, query]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 4.将query设置到http body上</span></span><br><span class="line">        <span class="keyword">if</span> (!query) &#123;</span><br><span class="line">            query = <span class="string">@""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (![mutableRequest valueForHTTPHeaderField:<span class="string">@"Content-Type"</span>]) &#123;</span><br><span class="line">            [mutableRequest setValue:<span class="string">@"application/x-www-form-urlencoded"</span> forHTTPHeaderField:<span class="string">@"Content-Type"</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        [mutableRequest setHTTPBody:[query dataUsingEncoding:<span class="keyword">self</span><span class="variable">.stringEncoding</span>]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mutableRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中在第二部构建查询字符串时，提供了一个<code>queryStringSerialization</code> block，可以自定义这个构建方法。当然如果没设置这个 block，就会使用默认的 <code>AFHTTPRequestQueryStringDefaultStyle</code> case，调用 <code>AFQueryStringFromParameters()</code>方法来构建字符串。</p>
<h4 id="AFQueryStringFromParameters_方法">AFQueryStringFromParameters 方法</h4><p>这一步主要是将参数用 &amp; 连接起来，其核心方法有三个：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">FOUNDATION_EXPORT <span class="built_in">NSArray</span> * AFQueryStringPairsFromDictionary(<span class="built_in">NSDictionary</span> *dictionary);</span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSArray</span> * AFQueryStringPairsFromKeyAndValue(<span class="built_in">NSString</span> *key, <span class="keyword">id</span> value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建字符串 用&amp;连接</span></span><br><span class="line"><span class="built_in">NSString</span> * AFQueryStringFromParameters(<span class="built_in">NSDictionary</span> *parameters) &#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *mutablePairs = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="keyword">for</span> (AFQueryStringPair *pair <span class="keyword">in</span> AFQueryStringPairsFromDictionary(parameters)) &#123;</span><br><span class="line">        <span class="comment">// URLEncoded 处理</span></span><br><span class="line">        [mutablePairs addObject:[pair URLEncodedStringValue]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [mutablePairs componentsJoinedByString:<span class="string">@"&amp;"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSArray</span> * AFQueryStringPairsFromDictionary(<span class="built_in">NSDictionary</span> *dictionary) &#123;</span><br><span class="line">    <span class="keyword">return</span> AFQueryStringPairsFromKeyAndValue(<span class="literal">nil</span>, dictionary);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSArray</span> * AFQueryStringPairsFromKeyAndValue(<span class="built_in">NSString</span> *key, <span class="keyword">id</span> value) &#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *mutableQueryStringComponents = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据需要排列的对象的description来进行升序排列，并且selector使用的是compare:</span></span><br><span class="line">    <span class="comment">// 因为对象的description返回的是NSString，所以此处compare:使用的是NSString的compare函数</span></span><br><span class="line">    <span class="comment">// 即@[@"foo", @"bar", @"bae"] ----&gt; @[@"bae", @"bar",@"foo"]</span></span><br><span class="line">    <span class="built_in">NSSortDescriptor</span> *sortDescriptor = [<span class="built_in">NSSortDescriptor</span> sortDescriptorWithKey:<span class="string">@"description"</span> ascending:<span class="literal">YES</span> selector:<span class="keyword">@selector</span>(compare:)];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 value 类型</span></span><br><span class="line">    <span class="comment">// 递归调用并解析</span></span><br><span class="line">    <span class="comment">// 因为不能保证NSDictionary的value中存放的是一个NSArray、NSSet</span></span><br><span class="line">    <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSDictionary</span> class]]) &#123;</span><br><span class="line">        <span class="built_in">NSDictionary</span> *dictionary = value;</span><br><span class="line">        <span class="comment">// Sort dictionary keys to ensure consistent ordering in query string, which is important when deserializing potentially ambiguous sequences, such as an array of dictionaries</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> nestedKey <span class="keyword">in</span> [dictionary<span class="variable">.allKeys</span> sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &#123;</span><br><span class="line">            <span class="keyword">id</span> nestedValue = dictionary[nestedKey];</span><br><span class="line">            <span class="keyword">if</span> (nestedValue) &#123;</span><br><span class="line">                [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue((key ? [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@[%@]"</span>, key, nestedKey] : nestedKey), nestedValue)];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSArray</span> class]]) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *array = value;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> nestedValue <span class="keyword">in</span> array) &#123;</span><br><span class="line">            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@[]"</span>, key], nestedValue)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSSet</span> class]]) &#123;</span><br><span class="line">        <span class="built_in">NSSet</span> *set = value;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> obj <span class="keyword">in</span> [set sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &#123;</span><br><span class="line">            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue(key, obj)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 结束递归 最后一个 value 为 NSString</span></span><br><span class="line">        [mutableQueryStringComponents addObject:[[AFQueryStringPair alloc] initWithField:key value:value]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mutableQueryStringComponents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是在 <code>AFQueryStringPairsFromKeyAndValue()</code> 方法中是采用递归调用解析参数类型的，直到最后一个 value 的类型为 NSString 结束递归，在此同时也将一个 <code>AFQueryStringPair</code> 对象添加到数组中。来看一下这个对象的结构：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFQueryStringPair</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">// 为 key</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> field;</span><br><span class="line"><span class="comment">// 为 value</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> value;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithField:(<span class="keyword">id</span>)field value:(<span class="keyword">id</span>)value;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)URLEncodedStringValue;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>可以看出这是个专门存放 key 和 value 的类，其提供了一个初始化方法和一个序列化方法。</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)URLEncodedStringValue &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable">self</span>.value || [<span class="variable">self</span>.value isEqual:[NSNull <span class="literal">null</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> AFPercentEscapedStringFromString([<span class="variable">self</span>.<span class="keyword">field</span> description]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [NSString stringWithFormat:@<span class="string">"%@=%@"</span>, AFPercentEscapedStringFromString([<span class="variable">self</span>.<span class="keyword">field</span> description]), AFPercentEscapedStringFromString([<span class="variable">self</span>.value description])];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过序列化方法将 key 和 value 转化成 <code>key=value</code> 这种形式。</p>
<h3 id="AFURLResponseSerialization">AFURLResponseSerialization</h3><p>AFURLResponseSerialization 只是个协议，其内部提供了一个方法用以序列化返回数据。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AFURLResponseSerialization</span> &lt;<span class="title">NSObject</span>, <span class="title">NSSecureCoding</span>, <span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (nullable <span class="keyword">id</span>)responseObjectForResponse:(nullable <span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                           data:(nullable <span class="built_in">NSData</span> *)data</span><br><span class="line">                          error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error <span class="built_in">NS_SWIFT_NOTHROW</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>同时也要遵循 NSObject、NSSecureCoding 和 NSCopying 这三个协议，实现安全编码、拷贝等。</p>
<p>在 AFNetworking 内部里遵循这个协议并返回特定的数据类型有 7 种，分别是：</p>
<ul>
<li>AFHTTPResponseSerializer</li>
<li>AFJSONResponseSerializer</li>
<li>AFXMLParserResponseSerializer</li>
<li>AFXMLDocumentResponseSerializer</li>
<li>AFPropertyListResponseSerializer</li>
<li>AFImageResponseSerializer</li>
<li>AFCompoundResponseSerializer</li>
</ul>
<p>因为 AFJSONResponseSerializer 为 AFHTTPSessionManager 创建时默认的 responseSerializer，这里以 AFJSONResponseSerializer 的相关方法为例。</p>
<h4 id="responseObjectForResponse_方法">responseObjectForResponse 方法</h4><p><code>responseObjectForResponse:</code> 方法是 AFURLResponseSerialization 协议的方法，这里以 AFJSONResponseSerializer 所实现的 <code>responseObjectForResponse:</code> 方法为例：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)responseObjectForResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                           data:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                          error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 验证请求的有效性</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> validateResponse:(<span class="built_in">NSHTTPURLResponse</span> *)response data:data error:error]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, <span class="built_in">NSURLErrorCannotDecodeContentData</span>, AFURLResponseSerializationErrorDomain)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解决一个空格引起的 bug</span></span><br><span class="line">    <span class="keyword">id</span> responseObject = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// Workaround for behavior of Rails to return a single space for `head :ok` (a workaround for a bug in Safari), which is not interpreted as valid input by NSJSONSerialization.</span></span><br><span class="line">    <span class="comment">// See https://github.com/rails/rails/issues/1742</span></span><br><span class="line">    <span class="built_in">BOOL</span> isSpace = [data isEqualToData:[<span class="built_in">NSData</span> dataWithBytes:<span class="string">" "</span> length:<span class="number">1</span>]];</span><br><span class="line">    <span class="comment">// 序列化 JSON</span></span><br><span class="line">    <span class="keyword">if</span> (data<span class="variable">.length</span> &gt; <span class="number">0</span> &amp;&amp; !isSpace) &#123;</span><br><span class="line">        responseObject = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:<span class="keyword">self</span><span class="variable">.readingOptions</span> error:&amp;serializationError];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移除 JSON 中的 null</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.removesKeysWithNullValues</span> &amp;&amp; responseObject) &#123;</span><br><span class="line">        responseObject = AFJSONObjectByRemovingKeysWithNullValues(responseObject, <span class="keyword">self</span><span class="variable">.readingOptions</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        *error = AFErrorWithUnderlyingError(serializationError, *error);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> responseObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见其核心就是序列化 JSON，将 responseObject 转化为 JSON 格式的数据。同理，在 AFHTTPResponseSerializer 中的 <code>responseObjectForResponse:</code> 方法就是返回原生的 HTTP 数据，如下：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (id)responseObjectForResponse:(<span class="type">NSURLResponse</span> *)response</span><br><span class="line">                           <span class="typedef"><span class="keyword">data</span>:<span class="container">(<span class="type">NSData</span> *)</span><span class="keyword">data</span></span></span><br><span class="line">                          error:(<span class="type">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    [self validateResponse:(<span class="type">NSHTTPURLResponse</span> *)response <span class="typedef"><span class="keyword">data</span>:<span class="keyword">data</span> error:error];</span></span><br><span class="line"></span><br><span class="line">    return <span class="typedef"><span class="keyword">data</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么相应的剩余的都类似，区别只是 <code>responseObjectForResponse:</code> 方法的实现不同。</p>
<h3 id="总结">总结</h3><p>AFNetworking 源码阅读笔记就记录到这里了，剩余的类都在<a href="https://github.com/v2panda/PDSourceNotes/tree/master/AFNetworking/AFNetworking-notes" target="_blank" rel="external">源码注释</a>里有注释，感兴趣的可以看看，这里就不细说了。</p>
<h3 id="Reference">Reference</h3><p><a href="https://github.com/AFNetworking/AFNetworking/" target="_blank" rel="external">AFNetworking</a><br><a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/AFNetworking/AFNetworking%20%E6%A6%82%E8%BF%B0%EF%BC%88%E4%B8%80%EF%BC%89.md" target="_blank" rel="external">AFNetworking 概述</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xnmlk.com1.z0.glb.clouddn.com/afnetworking-logo.png&quot; alt=&quot;AFNetworking&quot;&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/AFNetworking/AFNetworking/&quot;&gt;AFNetworking&lt;/a&gt; 是 Objective-C 中用于网络请求的第三方框架，我们一般使用它来封装网络请求，这篇文章记录了阅读 AFNetworking(Version 3.1.0) 源码的笔记，简单的研究了它的实现细节。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AFNetworking 源码阅读笔记（二）</title>
    <link href="http://v2panda.com/2016/09/29/afnetworking-2/"/>
    <id>http://v2panda.com/2016/09/29/afnetworking-2/</id>
    <published>2016-09-29T13:30:02.000Z</published>
    <updated>2016-09-29T13:39:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xnmlk.com1.z0.glb.clouddn.com/afnetworking-logo.png" alt="AFNetworking"><br><a href="https://github.com/AFNetworking/AFNetworking/" target="_blank" rel="external">AFNetworking</a> 是 Objective-C 中用于网络请求的第三方框架，我们一般使用它来封装网络请求，这篇文章记录了阅读 AFNetworking(Version 3.1.0) 源码的笔记，简单的研究了它的实现细节。</p>
<a id="more"></a>
<h3 id="AFHTTPSessionManager">AFHTTPSessionManager</h3><p>AFHTTPSessionManager 继承自 AFURLSessionManager，主要是提供了一系列对外暴露的属性和方法，如下图：</p>
<p><img src="http://7xnmlk.com1.z0.glb.clouddn.com/af-httpsm.png" alt=""></p>
<p>可以看出对外暴露的有：</p>
<p>三个属性：<code>baseURL</code>、<code>requestSerializer</code>、<code>responseSerializer</code></p>
<p>三个初始化方法：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ <span class="list">(<span class="keyword">instancetype</span>)</span>manager</span><br></pre></td></tr></table></figure>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(instancetype)</span>initWithBaseURL:<span class="params">(nullable <span class="variable">NSURL</span> *)</span>url</span></span><br></pre></td></tr></table></figure>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(instancetype)</span>initWithBaseURL:<span class="params">(nullable <span class="variable">NSURL</span> *)</span>url</span><br><span class="line">           sessionConfiguration:<span class="params">(nullable <span class="variable">NSURLSessionConfiguration</span> *)</span>configuration</span></span><br></pre></td></tr></table></figure>
<p>还有一系列请求方法：<code>GET</code>、<code>HEAD</code>、<code>POST</code>、<code>PUT</code>、<code>PATCH</code>、<code>DELETE</code>。</p>
<h4 id="初始化与请求方法">初始化与请求方法</h4><p>其中所有的初始化方法，最后都到<code>initWithBaseURL:</code>方法里来初始化对象，需要注意的是默认 response 是 JSON 类型的。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithBaseURL:(<span class="built_in">NSURL</span> *)url</span><br><span class="line">           sessionConfiguration:(<span class="built_in">NSURLSessionConfiguration</span> *)configuration</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.baseURL</span> = url;</span><br><span class="line">	<span class="comment">// 默认的 request 和 response</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.requestSerializer</span> = [AFHTTPRequestSerializer serializer];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.responseSerializer</span> = [AFJSONResponseSerializer serializer];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而所有的请求方法，<code>GET</code>、<code>HEAD</code>、<code>POST</code>、<code>PUT</code>、<code>PATCH</code>、<code>DELETE</code> 等最终都是调用的 <code>dataTaskWithHTTPMethod:</code> 方法创建 task，区别是传递的method名称不同，方法体如下：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">NSError *serializationError = <span class="keyword">nil</span>;</span><br><span class="line">   <span class="comment">// 创建 NSMutableURLRequest</span></span><br><span class="line">   NSMutableURLRequest *request = [<span class="keyword">self</span>.requestSerializer requestWithMethod:<span class="function"><span class="keyword">method</span> <span class="title">URLString</span>:</span>[[NSURL URLWithString:URLString relativeToURL:<span class="keyword">self</span>.baseURL] absoluteString] parameters:parameters error:&amp;serializationError];</span><br><span class="line">   </span><br><span class="line">   ...处理构建 request 产生的错误</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 创建 dataTask</span></span><br><span class="line">   __block NSURLSessionDataTask *dataTask = <span class="keyword">nil</span>;</span><br><span class="line">   dataTask = [<span class="keyword">self</span> dataTaskWithRequest:request</span><br><span class="line">                         uploadProgress:uploadProgress</span><br><span class="line">                       downloadProgress:downloadProgress</span><br><span class="line">                      completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) <span class="comment">&#123;</span><br><span class="line">...</span><br><span class="line">   &#125;</span>];</span><br><span class="line"></span><br><span class="line">   return dataTask;</span><br></pre></td></tr></table></figure>
<p>其中先创建 request，再根据 request 创建 dataTask。</p>
<h4 id="NSSecureCoding">NSSecureCoding</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@interface</span> <span class="string">AFHTTPSessionManager :</span> AFURLSessionManager &lt;NSSecureCoding, NSCopying&gt;</span><br></pre></td></tr></table></figure>
<p>可以看出 AFHTTPSessionManager 实现了 NSSecureCoding 和 NSCoding 协议，其中 NSSecureCoding 是基于 NSCoding 协议。</p>
<p>NSSecureCoding 是苹果在 iOS6 中引入的一个新协议，基于NSCoding。简单的说就是在数据归档过程加了数据类型检验，相对更安全一点，使用起来需要多实现一个方法：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@protocol</span> NSSecureCoding &lt;NSCoding&gt;</span><br><span class="line"><span class="variable">@required</span></span><br><span class="line">+ (BOOL)supportsSecureCoding;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="小结">小结</h4><p>总的来说 AFHTTPSessionManager 只是在 AFURLSessionManager 的基础上做了一层包装。</p>
<h3 id="AFURLSessionManager">AFURLSessionManager</h3><p>AFURLSessionManager 可以说是 AFNetworking 的核心类，相应的其内部实现也复杂许多，先来看一张图：<br><img src="http://7xnmlk.com1.z0.glb.clouddn.com/af-urlsm.png" alt=""><br>AFURLSessionManager.m 内部除了 AFURLSessionManager 的实现外，还包含两个自定义类的实现，AFURLSessionManagerTaskDelegate 主要为 task 提供进度管理功能，_AFURLSessionTaskSwizzling 则是修改 NSURLSessionTask 的 <code>resume</code> 和 <code>suspend</code> 方法，这里还是先从 AFURLSessionManager 初始化开始。</p>
<h4 id="初始化">初始化</h4><p>AFURLSessionManager 的初始化在<code>initWithSessionConfiguration:</code>方法里进行了一系列的配置：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// 默认为 defaultSessionConfiguration</span></span><br><span class="line">    <span class="keyword">if</span> (!configuration) &#123;</span><br><span class="line">        configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.sessionConfiguration</span> = configuration;</span><br><span class="line">    <span class="comment">// 初始化代理队列</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.operationQueue</span> = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.operationQueue</span><span class="variable">.maxConcurrentOperationCount</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 初始化 session</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.session</span> = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:<span class="keyword">self</span><span class="variable">.sessionConfiguration</span> delegate:<span class="keyword">self</span> delegateQueue:<span class="keyword">self</span><span class="variable">.operationQueue</span>];</span><br><span class="line">    <span class="comment">// 初始化 response 序列，默认为 JSON</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.responseSerializer</span> = [AFJSONResponseSerializer serializer];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// AFSecurityPolicy 是 AFNetworking 用来保证 HTTP 请求安全的类，它被 AFURLSessionManager 持有</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.securityPolicy</span> = [AFSecurityPolicy defaultPolicy];</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#if !TARGET_OS_WATCH</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.reachabilityManager</span> = [AFNetworkReachabilityManager sharedManager];</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">    <span class="comment">// 初始化用来存放 AFURLSessionManagerTaskDelegate 的字典</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.mutableTaskDelegatesKeyedByTaskIdentifier</span> = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line">    <span class="comment">// 初始化 NSLock</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.lock</span> = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.lock</span><span class="variable">.name</span> = AFURLSessionManagerLockName;</span><br><span class="line">    </span><br><span class="line">    ...为已有的 task 设置代理</span><br></pre></td></tr></table></figure>
<h4 id="创建_NSURLSessionTask">创建 NSURLSessionTask</h4><p>创建 NSURLSessionTask 的方法有以下三种：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">dataTaskWithRequest:</span></span><br><span class="line"></span><br><span class="line"><span class="label">uploadTaskWithRequest:</span></span><br><span class="line"></span><br><span class="line"><span class="label">downloadTaskWithRequest:</span></span><br></pre></td></tr></table></figure>
<p>这里以 <code>dataTaskWithRequest:</code> 方法为例，可以看出其是用 NSURLSession 的 <code>dataTaskWithRequest:</code>方法创建出 dataTask。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">__block NSURLSessionDataTask *dataTask = nil;</span><br><span class="line">   <span class="comment">// 解决iOS8之前的一个bug</span></span><br><span class="line">   url_session_manager_create_task_safely(^&#123;</span><br><span class="line">       <span class="comment">//  用NSURLSession创建NSURLSessionDataTask</span></span><br><span class="line">       dataTask = [self.session <span class="string">dataTaskWithRequest:</span>request];</span><br><span class="line">   &#125;);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 给data task添加了一个AFURLSessionManagerTaskDelegate</span></span><br><span class="line">   <span class="comment">// 主要为 task 提供进度管理功能</span></span><br><span class="line">   [self <span class="string">addDelegateForDataTask:</span>dataTask <span class="string">uploadProgress:</span>uploadProgressBlock <span class="string">downloadProgress:</span>downloadProgressBlock <span class="string">completionHandler:</span>completionHandler];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> dataTask;</span><br></pre></td></tr></table></figure>
<p>需要注意的是在创建完 dataTask 之后，又通过 <code>addDelegateForDataTask:</code>方法给 dataTask 添加了一个 AFURLSessionManagerTaskDelegate，这个 delegate 主要为 dataTask 提供上传下载的进度管理功能。</p>
<h4 id="NSURLSession_相关的代理方法">NSURLSession 相关的代理方法</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@interface</span> <span class="string">AFURLSessionManager :</span> NSObject &lt;NSURLSessionDelegate, NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate, NSSecureCoding, NSCopying&gt;</span><br></pre></td></tr></table></figure>
<p>AFURLSessionManager 遵循并实现了一系列 NSURLSession 相关的代理方法，不过 AFURLSessionManager 为所有的代理协议都提供了对应的 block 接口，这样不让用户自己实现相关方法，对外只暴露出 block。这里举个🌰：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (<span class="tag">void</span>)<span class="rule"><span class="attribute">URLSession</span>:<span class="value">(NSURLSession *)session</span><br><span class="line">didBecomeInvalidWithError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">    if (self.sessionDidBecomeInvalid) &#123;</span><br><span class="line">        self.<span class="function">sessionDidBecomeInvalid</span>(session, error)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attr_selector">[[NSNotificationCenter defaultCenter]</span> <span class="rule"><span class="attribute">postNotificationName</span>:<span class="value">AFURLSessionDidInvalidateNotification object:session]</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出在以上方法中，用户只需要调用这个 block， 就可以用来处理session无效的情况，这么做隐藏了细节，简化了调用。</p>
<h4 id="AFURLSessionManagerTaskDelegate">AFURLSessionManagerTaskDelegate</h4><p>AFURLSessionManagerTaskDelegate 继承自 NSObject，主要作用是为 dataTask 提供进度管理功能。</p>
<p>需要注意的是在 AFURLSessionManagerTaskDelegate 的 <code>setupProgressForTask</code>方法中将 NSProgress 和 NSURLSessionTask 进行了状态绑定，代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> 上传的totalUnitCount就对应期望发送(send)的数据大小，下载任务的就对应期望接收(receive)的数据大小。</span><br><span class="line"> </span><br><span class="line"> 接着就是设置这两个NSProgress对应的cancel、pause和resume这三个状态，正好对应session task的cancel、suspend和resume三个状态</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">self</span><span class="variable">.uploadProgress</span><span class="variable">.totalUnitCount</span> = task<span class="variable">.countOfBytesExpectedToSend</span>;</span><br><span class="line"><span class="keyword">self</span><span class="variable">.downloadProgress</span><span class="variable">.totalUnitCount</span> = task<span class="variable">.countOfBytesExpectedToReceive</span>;</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.uploadProgress</span> setCancellable:<span class="literal">YES</span>];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.uploadProgress</span> setCancellationHandler:^&#123;</span><br><span class="line">    __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">    [strongTask cancel];</span><br><span class="line">&#125;];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.uploadProgress</span> setPausable:<span class="literal">YES</span>];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.uploadProgress</span> setPausingHandler:^&#123;</span><br><span class="line">    __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">    [strongTask suspend];</span><br><span class="line">&#125;];</span><br><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span><span class="variable">.uploadProgress</span> respondsToSelector:<span class="keyword">@selector</span>(setResumingHandler:)]) &#123;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.uploadProgress</span> setResumingHandler:^&#123;</span><br><span class="line">        __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">        [strongTask resume];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span><span class="variable">.downloadProgress</span> setCancellable:<span class="literal">YES</span>];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.downloadProgress</span> setCancellationHandler:^&#123;</span><br><span class="line">    __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">    [strongTask cancel];</span><br><span class="line">&#125;];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.downloadProgress</span> setPausable:<span class="literal">YES</span>];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.downloadProgress</span> setPausingHandler:^&#123;</span><br><span class="line">    __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">    [strongTask suspend];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span><span class="variable">.downloadProgress</span> respondsToSelector:<span class="keyword">@selector</span>(setResumingHandler:)]) &#123;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.downloadProgress</span> setResumingHandler:^&#123;</span><br><span class="line">        __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">        [strongTask resume];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给两个progress添加KVO NSProgress的fractionCompleted属性（任务已经完成的比例，取值为0~1）</span></span><br><span class="line">[<span class="keyword">self</span><span class="variable">.downloadProgress</span> addObserver:<span class="keyword">self</span></span><br><span class="line">                        forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(fractionCompleted))</span><br><span class="line">                           options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">                           context:<span class="literal">NULL</span>];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.uploadProgress</span> addObserver:<span class="keyword">self</span></span><br><span class="line">                      forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(fractionCompleted))</span><br><span class="line">                         options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">                         context:<span class="literal">NULL</span>];</span><br></pre></td></tr></table></figure>
<h4 id="_AFURLSessionTaskSwizzling">_AFURLSessionTaskSwizzling</h4><p><code>_AFURLSessionTaskSwizzling</code> 的唯一功能就是修改 NSURLSessionTask 的 <code>resume</code> 和 <code>suspend</code> 方法，使用 <code>af_resume</code>、<code>af_suspend</code> 替换原有的实现，主要实现是在 <code>+load</code> 方法中实现了 method swizzling。</p>
<h3 id="总结">总结</h3><p>本文只列举了一些主要的知识点，详细的可以看<a href="https://github.com/v2panda/PDSourceNotes/tree/master/AFNetworking/AFNetworking-notes" target="_blank" rel="external">源码注释</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xnmlk.com1.z0.glb.clouddn.com/afnetworking-logo.png&quot; alt=&quot;AFNetworking&quot;&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/AFNetworking/AFNetworking/&quot;&gt;AFNetworking&lt;/a&gt; 是 Objective-C 中用于网络请求的第三方框架，我们一般使用它来封装网络请求，这篇文章记录了阅读 AFNetworking(Version 3.1.0) 源码的笔记，简单的研究了它的实现细节。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AFNetworking 源码阅读笔记（一）</title>
    <link href="http://v2panda.com/2016/09/26/afnetworking-1/"/>
    <id>http://v2panda.com/2016/09/26/afnetworking-1/</id>
    <published>2016-09-26T12:45:41.000Z</published>
    <updated>2016-09-26T12:49:25.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xnmlk.com1.z0.glb.clouddn.com/afnetworking-logo.png" alt="AFNetworking"><br><a href="https://github.com/AFNetworking/AFNetworking/" target="_blank" rel="external">AFNetworking</a> 是 Objective-C 中用于网络请求的第三方框架，我们一般使用它来封装网络请求，这篇文章记录了阅读 AFNetworking(Version 3.1.0) 源码的笔记，简单的研究了它的实现细节。</p>
<a id="more"></a>
<h3 id="前言">前言</h3><p>这里引用 <a href="https://github.com/Draveness" target="_blank" rel="external">@draveness</a> 的一张图来展示 AFNetworking 的整个架构：</p>
<p><img src="http://7xnmlk.com1.z0.glb.clouddn.com/afnetworking-arch.png" alt=""></p>
<p>本系列以此架构为依据，随后的文章会逐一分析 AFNetworking 的实现原理。</p>
<h3 id="流程">流程</h3><p>首先以<a href="https://github.com/AFNetworking/AFNetworking/" target="_blank" rel="external">官方 Demo</a> 中的一个 Get 方法为例，来探究 AFNetworking 网络请求的大致流程。</p>
<p><img src="http://7xnmlk.com1.z0.glb.clouddn.com/Get+%E6%96%B9%E6%B3%95.png" alt=""></p>
<ul>
<li>1.Get 请求入口 </li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)GET:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                   parameters:(<span class="keyword">id</span>)parameters</span><br><span class="line">                      success:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="keyword">id</span> responseObject))success</span><br><span class="line">                      failure:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="built_in">NSError</span> *error))failure</span><br></pre></td></tr></table></figure>
<ul>
<li>2.创建 NSURLSessionDataTask </li>
</ul>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">NSURLSessionDataTask</span> *)dataTaskWithHTTPMethod:(<span class="type">NSString</span> *)<span class="keyword">method</span></span><br><span class="line">                                       <span class="type">URLString</span>:(<span class="type">NSString</span> *)<span class="type">URLString</span></span><br><span class="line">                                      parameters:(id)parameters</span><br><span class="line">                                  uploadProgress:(nullable <span class="type">void</span> (^)(<span class="type">NSProgress</span> *uploadProgress)) uploadProgress</span><br><span class="line">                                downloadProgress:(nullable <span class="type">void</span> (^)(<span class="type">NSProgress</span> *downloadProgress)) downloadProgress</span><br><span class="line">                                         success:(<span class="type">void</span> (^)(<span class="type">NSURLSessionDataTask</span> *, id))success</span><br><span class="line">                                         failure:(<span class="type">void</span> (^)(<span class="type">NSURLSessionDataTask</span> *, <span class="type">NSError</span> *))failure</span><br></pre></td></tr></table></figure>
<ul>
<li>3.创建 NSURLSessionDataTask 前先创建 NSMutableURLRequest </li>
</ul>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (NSMutableURLRequest *)requestWithMethod:(NSString *)<span class="function"><span class="keyword">method</span></span><br><span class="line">                                 <span class="title">URLString</span>:</span>(NSString *)URLString</span><br><span class="line">                                parameters:(id)parameters</span><br><span class="line">                                     error:(NSError *__autoreleasing *)error</span><br></pre></td></tr></table></figure>
<ul>
<li>4.用 request 创建 NSURLSessionDataTask </li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                               uploadProgress:(nullable <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">                             downloadProgress:(nullable <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">                            completionHandler:(nullable <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> _Nullable responseObject,  <span class="built_in">NSError</span> * _Nullable error))completionHandler</span><br></pre></td></tr></table></figure>
<ul>
<li>5.给 dataTask 添加 Delegate (主要为 task 提供进度管理功能) </li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addDelegateForDataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">                uploadProgress:(nullable <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">              downloadProgress:(nullable <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">             completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error))completionHandler</span><br></pre></td></tr></table></figure>
<p>以上方法是调用链上的主要方法，将在下文逐一解释。</p>
<h3 id="1-Get_请求入口">1.Get 请求入口</h3><p>具体方法体如下:</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 创建这个 NSURLSessionDataTask</span><br><span class="line">   NSURLSessionDataTask <span class="keyword">*</span>dataTask = [self dataTaskWithHTTPMethod:<span class="comment">@"GET"</span></span><br><span class="line">                                                       URLString:URLString</span><br><span class="line">                                                      parameters:parameters</span><br><span class="line">                                                  uploadProgress:nil</span><br><span class="line">                                                downloadProgress:downloadProgress</span><br><span class="line">                                                         success:success</span><br><span class="line">                                                         failure:failure];</span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">    <span class="keyword">*</span>  session task的几种状态的操作函数</span><br><span class="line">       suspend -- 可以让当前的任务暂停</span><br><span class="line">       resume ---- 方法不仅可以启动任务,还可以唤醒suspend状态的任务</span><br><span class="line">       cancel ----- 方法可以取消当前的任务,你也可以向处于suspend状态的任务发送cancel消息,任务如果被取消便不能再恢复到之前的状态.</span><br><span class="line">    <span class="keyword">*</span>/</span><br><span class="line">   [dataTask resume];</span><br></pre></td></tr></table></figure>
<p>使用 GET 类型的 Request 来创建并运行一个 NSURLSessionDataTask，这里要注意的是用<code>[dataTask resume]</code>来开启这个 task。</p>
<h3 id="2-创建_NSURLSessionDataTask">2.创建 NSURLSessionDataTask</h3><p>主要方法体如下：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">   <span class="comment">// 创建 NSMutableURLRequest</span></span><br><span class="line">   NSMutableURLRequest *request = [<span class="keyword">self</span>.requestSerializer requestWithMethod:<span class="function"><span class="keyword">method</span> <span class="title">URLString</span>:</span>[[NSURL URLWithString:URLString relativeToURL:<span class="keyword">self</span>.baseURL] absoluteString] parameters:parameters error:&amp;serializationError];</span><br><span class="line">   <span class="comment">// 处理构建 request 产生的错误</span></span><br><span class="line">	...</span><br><span class="line">   <span class="comment">// 创建 dataTask</span></span><br><span class="line">   __block NSURLSessionDataTask *dataTask = <span class="keyword">nil</span>;</span><br><span class="line">   dataTask = [<span class="keyword">self</span> dataTaskWithRequest:request</span><br><span class="line">                         uploadProgress:uploadProgress</span><br><span class="line">                       downloadProgress:downloadProgress</span><br><span class="line">                      completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) <span class="comment">&#123;</span><br><span class="line">       if (error) &#123;</span><br><span class="line">           if (failure) &#123;</span><br><span class="line">               failure(dataTask, error);</span><br><span class="line">           &#125;</span></span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="comment">&#123;</span><br><span class="line">           if (success) &#123;</span><br><span class="line">               success(dataTask, responseObject);</span><br><span class="line">           &#125;</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;];</span><br><span class="line"></span><br><span class="line">   return dataTask;</span><br></pre></td></tr></table></figure>
<p><code>dataTaskWithHTTPMethod:</code>这个函数的实现主要分两部分，一部分是构建NSMutableURLRequest，另一部分是根据已构建好的 Request 来创建 DataTask。<br>其中 Request 是由传递的 method 来创建，这里传递的是 GET，其它参数还有HEAD、POST、PUT、PATCH、DELETE 。</p>
<h3 id="3-创建_NSMutableURLRequest">3.创建 NSMutableURLRequest</h3><p>使用指定的 HTTP method 和 URLString 来构建一个 NSMutableURLRequest 对象实例，主要方法体如下：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> 	// 参数断言</span><br><span class="line">   <span class="type">NSParameterAssert</span>(<span class="keyword">method</span>);</span><br><span class="line">   <span class="type">NSParameterAssert</span>(<span class="type">URLString</span>);</span><br><span class="line"></span><br><span class="line">   <span class="type">NSURL</span> *url = [<span class="type">NSURL</span> <span class="type">URLWithString</span>:<span class="type">URLString</span>];</span><br><span class="line"></span><br><span class="line">   <span class="type">NSParameterAssert</span>(url);</span><br><span class="line"></span><br><span class="line">   // 使用url构建并初始化<span class="type">NSMutableURLRequest</span>，然后设置<span class="type">HTTPMethod</span></span><br><span class="line">   <span class="type">NSMutableURLRequest</span> *mutableRequest = [[<span class="type">NSMutableURLRequest</span> alloc] initWithURL:url];</span><br><span class="line">   mutableRequest.<span class="type">HTTPMethod</span> = <span class="keyword">method</span>;</span><br><span class="line"></span><br><span class="line">   // 给<span class="type">NSMutableURLRequest</span>自带的属性赋值</span><br><span class="line">   // 然后通过判断mutableObservedChangedKeyPaths（<span class="type">NSMutableSet</span>）中是否有这个keyPath，来设定mutableRequest对应的keyPath值</span><br><span class="line">   // <span class="type">AFHTTPRequestSerializerObservedKeyPaths</span>这个数组里的属性是固定的，且在 init 方法里全都 <span class="type">KVO</span> 了</span><br><span class="line">   /**</span><br><span class="line">    *  当 <span class="type">AFHTTPRequestSerializerObserverContext</span> 中有 value 变化了(且变化后的新值不为 <span class="type">NSNull</span> null)，就会响应 observerValueForKeyPath 这个函数，从而mutableObservedChangedKeyPaths就会添加这个 keyPath</span><br><span class="line">    */</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">NSString</span> *keyPath <span class="keyword">in</span> <span class="type">AFHTTPRequestSerializerObservedKeyPaths</span>()) &#123;</span><br><span class="line">       <span class="keyword">if</span> ([self.mutableObservedChangedKeyPaths containsObject:keyPath]) &#123;</span><br><span class="line">           [mutableRequest setValue:[self valueForKeyPath:keyPath] forKey:keyPath];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 将传入的parameters进行编码，并添加到request中</span><br><span class="line">   /**</span><br><span class="line">    *  一般我们请求都会按key=value的方式带上各种参数，<span class="type">GET</span>方法参数直接加在<span class="type">URL</span>上，<span class="type">POST</span>方法放在body上，<span class="type">NSURLRequest</span>没有封装好这个参数的解析，只能我们自己拼好字符串。<span class="type">AFNetworking</span>提供了接口，让参数可以是<span class="type">NSDictionary</span>, <span class="type">NSArray</span>, <span class="type">NSSet</span>这些类型，再由内部解析成字符串后赋给<span class="type">NSURLRequest</span>。</span><br><span class="line">    */</span><br><span class="line">   mutableRequest = [[self requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> mutableRequest;</span><br></pre></td></tr></table></figure>
<p> 如果 method 是 GET、HEAD、DELETE，那 parameter 将会被用来构建一个基于 url 编码的查询字符串（query url），并且这个字符串会直接加到request的url后面。对于 POST/PUT，它们会根据 parameterEncoding 属性进行编码，而后加到 request 的 http body 上。</p>
<h3 id="4-用_request_创建_NSURLSessionDataTask">4.用 request 创建 NSURLSessionDataTask</h3><p>主要方法体如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</span><br><span class="line"><span class="comment">// 解决iOS8之前的一个bug</span></span><br><span class="line">url_session_manager_create_task_safely(^&#123;</span><br><span class="line">    <span class="comment">//  用NSURLSession创建NSURLSessionDataTask</span></span><br><span class="line">    dataTask = [<span class="keyword">self</span><span class="variable">.session</span> dataTaskWithRequest:request];</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>用 NSURLSession 的 <code>dataTaskWithRequest:</code>方法来创建 dataTask，这里需要注意的是方法被一个<code>url_session_manager_create_task_safely</code>的 block 包起来，这里是为了解决 iOS 8 上的一个 <a href="https://github.com/AFNetworking/AFNetworking/issues/2093" target="_blank" rel="external">bug</a>。</p>
<h3 id="5-给_dataTask_添加_Delegate">5.给 dataTask 添加 Delegate</h3><p>在这个方法里给 dataTask 添加了一个 AFURLSessionManagerTaskDelegate，并为 dataTask 提供进度管理功能，具体的是在<code>[self setDelegate:delegate forTask:dataTask]</code>方法：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NSParameterAssert(task);</span><br><span class="line">   NSParameterAssert(<span class="keyword">delegate</span>);</span><br><span class="line"></span><br><span class="line">   [<span class="keyword">self</span>.lock lock];</span><br><span class="line">   <span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = <span class="keyword">delegate</span>;</span><br><span class="line">   <span class="comment">// 设置uploadProgress和downloadProgress这两个NSProgress变量</span></span><br><span class="line">   [<span class="keyword">delegate</span> setupProgressForTask:task];</span><br><span class="line">   <span class="comment">// 给session task添加KVO</span></span><br><span class="line">   [<span class="keyword">self</span> addNotificationObserverForTask:task];</span><br><span class="line">   [<span class="keyword">self</span>.lock unlock];</span><br></pre></td></tr></table></figure>
<p>这里首先把<code>task.taskIdentifier</code>作为 key，<code>delegate</code> 作为 value 存在一个 MutableDictionary 里，然后设置上传和下载两个 progress，并给 task 添加上启动和暂停的 KVO。</p>
<h3 id="小结">小结</h3><p>通过这个流程可以初步了解 AFNetworking 内部方法调用关系，当然也可以看出其实 AFNetworking 就是对 NSURLSession 的高度地封装。随后的文章会结合源码，来深入理解 AFNetworking 的实现原理。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xnmlk.com1.z0.glb.clouddn.com/afnetworking-logo.png&quot; alt=&quot;AFNetworking&quot;&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/AFNetworking/AFNetworking/&quot;&gt;AFNetworking&lt;/a&gt; 是 Objective-C 中用于网络请求的第三方框架，我们一般使用它来封装网络请求，这篇文章记录了阅读 AFNetworking(Version 3.1.0) 源码的笔记，简单的研究了它的实现细节。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SimpleWeather 2.0 - 基于React Native的重构</title>
    <link href="http://v2panda.com/2016/08/22/simpleweather/"/>
    <id>http://v2panda.com/2016/08/22/simpleweather/</id>
    <published>2016-08-22T12:37:57.000Z</published>
    <updated>2016-08-22T12:42:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>SimpleWeather 一个简单的天气应用。</p>
<p>地址：<a href="https://github.com/v2panda/SimpleWeather" target="_blank" rel="external">https://github.com/v2panda/SimpleWeather</a></p>
<p>SimpleWeather 是我写的第一个 App，算是学 iOS 开发的第一次实践，但现在看看以前的代码，各种问题、漏洞百出，无法忍受。于是决定重构出2.0版本，这次采用 React Native 开发，算是整个重构了一遍。</p>
<a id="more"></a>
<h3 id="前言">前言</h3><p>当然在实践之前还得先学习 React Native 相关知识，在这之前我没用过 React 更没学过 React Native，所以这块算是从零开始。不过我认为学东西，结合实际去学效率更高，否则学过之后还是需要吃回头草，与其如此浪费时间，还不如让学习直接融入到开发中去。</p>
<p>当然说是这么说，但该有的基础知识和基本概念还是得有的。这里我看了一本书《React Native 入门与实战》，这本书在买时，京东React Native 相关排第一，一些朋友也都推荐这本书。看完后觉得书写的确实不错，作为 React Native 入门读物算是够了。但不幸的是 React Native 和 Swift 一样，都是出来时间不长，语法、API 还在飞速发展阶段，所以有种说法叫 《React Native/Swift 从入门到再入门》，尤其是这本书 React Native 版本是 v0.14的，而现在的 React Native 版本是 v0.31，这之间有将近20个版本的差距。而改动最大的是从0.18版本开始，React Native 已经全面转向 ES6 ，于是我就悲剧的上官网重新入门了一次。</p>
<p><img src="http://7xnmlk.com1.z0.glb.clouddn.com/haizi.jpeg" alt=""></p>
<p>所以如果有朋友想学习 React Native，不再建议看《React Native 入门与实战》或者任何实体书籍，直接上官网学习即可。</p>
<h3 id="为什么要重构？">为什么要重构？</h3><ul>
<li>觉得以前写的代码太烂</li>
<li>充实业余时间，要是一段时间我什么东西都没折腾出来，我会感到很不安</li>
<li>重构可以帮我整理自己的思路，优化以前的烂代码</li>
<li>找回按自己意愿编程的感觉(这跟工作上的编程是完全不同的)</li>
</ul>
<p>又回到了这个老问题，当然这次除了以上原因以外，一个主要因素就是学习 React Native，尝试用 JS 的语法编写原生 App。对于一个传统的客户端开发码农来说，React Native 重新让我认识了客户端开发。</p>
<h3 id="总结">总结</h3><p>SimpleWeather 这个 App 页面少，功能简单，这次也没有加新功能，总体来说重构的难度不大，于是大多的时间花在了 React Native 语法和 Flex 布局上，总的来说这是学习 React Native 的一次简单实践。</p>
<p>关于 React Native 与 Native 之间的优缺点，有很多文章已经总结过了，这里我也不总结，而在 React Native 上我还是个 newbie ，还有很多东西需要学习，当然这些需要结合实际去学。学东西我认为直接融入到开发中去是最好的，虽然学习和使用的过程可能会变得更加艰难，但是这样学习知识效果更好而且该踩的坑都会踩到，所以计划以后有时间用 React Native 写一个更复杂的App。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SimpleWeather 一个简单的天气应用。&lt;/p&gt;
&lt;p&gt;地址：&lt;a href=&quot;https://github.com/v2panda/SimpleWeather&quot;&gt;https://github.com/v2panda/SimpleWeather&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SimpleWeather 是我写的第一个 App，算是学 iOS 开发的第一次实践，但现在看看以前的代码，各种问题、漏洞百出，无法忍受。于是决定重构出2.0版本，这次采用 React Native 开发，算是整个重构了一遍。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【译】Xcode Search the Hidden Gems</title>
    <link href="http://v2panda.com/2016/08/15/xcodesearch/"/>
    <id>http://v2panda.com/2016/08/15/xcodesearch/</id>
    <published>2016-08-15T12:44:08.000Z</published>
    <updated>2016-08-22T12:49:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xnmlk.com1.z0.glb.clouddn.com/xcodesearch_0.png" alt=""></p>
<p>作为软件开发人员,我们常常会花大量时间去阅读代码。 <a href="https://twitter.com/unclebobmartin" target="_blank" rel="external">Robert C. Martin</a> 在他的<a href="http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882" target="_blank" rel="external">Clean Code</a>中说道:</p>
<blockquote>
<p>Indeed, the ratio of time spent reading versus writing is well over 10 to 1. We are constantly reading old code as part of the effort to write new code.</p>
</blockquote>
<p>然而直接阅读整个代码库是不实际的，当你加入一个新项目，浏览一些开源库或着为一个大型代码库提交代码。搜索就会成为一个非常有用的工具，在这里我们将去深入了解隐藏在 Xcode 的导航器里的搜索。</p>
<a id="more"></a>
<h3 id="1_:_Patterns">1 : Patterns</h3><p>直接在 Xcode 搜索文本是非常容易的，按下 Command-Shift-F 输入你想搜索的文本就可以了。而仅仅这样是不够的，当我们想要一个更高级的搜索，比如想要搜索一个包含 URLs 的字符串。这是很常见的需求，苹果也帮我们实现了这个功能即 – 通配符模式。</p>
<p>首先单击放大镜按钮旁边的下拉按钮，如下图：</p>
<p><img src="http://7xnmlk.com1.z0.glb.clouddn.com/xcodesearch_1.png" alt="Search Options"></p>
<p>然后会看到一个下拉选择列表：</p>
<p><img src="http://7xnmlk.com1.z0.glb.clouddn.com/xcodesearch_2.png" alt="List of Available Patterns"></p>
<p>点击列表中的 URL 模式搜索字段，就会得到想要的结果：</p>
<p><img src="http://7xnmlk.com1.z0.glb.clouddn.com/xcodesearch_3.png" alt="Strings Representing URLs"></p>
<h3 id="2_:_Definitions">2 : Definitions</h3><p>Xcode 还提供了搜索选项来帮助我们理解项目代码结构。比方说，想搜索到项目中所有带 shared 的定义，而且假设项目中所有的单例也是以 <code>shared</code> 开头，类似 <code>shared*</code>。</p>
<p>如果仅仅搜索 <code>shared</code>，会得到很多结果：</p>
<p><img src="http://7xnmlk.com1.z0.glb.clouddn.com/xcodesearch_4.png" alt="Default Search Results"></p>
<p>这当然不是我们想要的，点击 Text 切换选择到 Definitions 来缩小搜索结果：</p>
<p><img src="http://7xnmlk.com1.z0.glb.clouddn.com/xcodesearch_5.png" alt="Definitions Option
"></p>
<p>就像这样：</p>
<p><img src="http://7xnmlk.com1.z0.glb.clouddn.com/xcodesearch_6.png" alt="Search Results Narrowed to Definitions"></p>
<p>得到了我们想要的结果，当然也可以使用这个去过滤结构体、枚举、枚举选项等等。</p>
<h3 id="3:_Search_Scopes">3: Search Scopes</h3><p>选择一个经常要搜索的项目:</p>
<p><img src="http://7xnmlk.com1.z0.glb.clouddn.com/xcodesearch_7.png" alt="Scopes Menu"></p>
<p>让我们想象一下，假如我们的项目是 Objective-C/Swift 代码混合的代码库。(它不是很难想象,对吧?😉)。这时我们想在 Swift 文件里搜索些东西，我们可以很容易的自定义搜索范围。点击 <em>New Scope</em> 按钮，选择搜索结果的过滤：<em>Location, Name, Path, Path Extension and Type</em>。Type 似乎是一个非常合适的选择，但不幸的是，这里没有 Swift :</p>
<p><img src="http://7xnmlk.com1.z0.glb.clouddn.com/xcodesearch_8.png" alt="No Swift here ¯\_(ツ)_/¯"></p>
<p>所以，我们用 <em>Path Extension</em> 来替代，如：</p>
<p><img src="http://7xnmlk.com1.z0.glb.clouddn.com/xcodesearch_9.png" alt="Scope Filtering .swift Files"></p>
<h3 id="4:_Call_Hierarchy">4: Call Hierarchy</h3><p>Xcode 7中增加了一个新功能，可以直接搜索调用的层次结构。通过它，我们可以更直观的查看或使用方法和函数。我不经常使用它，但是当我用到它时会节省很多时间。</p>
<p><img src="http://7xnmlk.com1.z0.glb.clouddn.com/xcodesearch_10.png" alt="Call Hierarchy Search Example"></p>
<h3 id="When_Not_to_Search">When Not to Search</h3><p>在Xcode中 Find navigator 非常强大，它不仅仅只有搜索功能。当我们要找东西时，搜索并不总是最好的解决方法。例如，当我们要查看一些属性的定义时，最好的方法是将鼠标移动到属性上并按下 Command-Control-J 查看，这样比直接搜索它的定义要好得多。或者当我们想看看某些方法的调用情况，我们可以直接按下(Control-1)菜单来查看。</p>
<p><img src="http://7xnmlk.com1.z0.glb.clouddn.com/xcodesearch_11.png" alt="Related Items Menu"></p>
<h3 id="Conclusion">Conclusion</h3><p>搜索在 Xcode 中变得越来越强大，它帮助我们更容易的阅读自己的代码或第三方代码。正如所有其他工具(或任何生活中)一样，它也带有一些权衡，但是我们可以选择使用最好的工具来工作。</p>
<blockquote>
<p>作者:Arkadiusz Holko</p>
<p>原文链接:<a href="http://holko.pl/2016/04/26/xcode-search/" target="_blank" rel="external">http://holko.pl/2016/04/26/xcode-search/</a></p>
<p>原文日期:26 Apr 2016</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xnmlk.com1.z0.glb.clouddn.com/xcodesearch_0.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;作为软件开发人员,我们常常会花大量时间去阅读代码。 &lt;a href=&quot;https://twitter.com/unclebobmartin&quot;&gt;Robert C. Martin&lt;/a&gt; 在他的&lt;a href=&quot;http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882&quot;&gt;Clean Code&lt;/a&gt;中说道:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Indeed, the ratio of time spent reading versus writing is well over 10 to 1. We are constantly reading old code as part of the effort to write new code.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然而直接阅读整个代码库是不实际的，当你加入一个新项目，浏览一些开源库或着为一个大型代码库提交代码。搜索就会成为一个非常有用的工具，在这里我们将去深入了解隐藏在 Xcode 的导航器里的搜索。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS单元测试</title>
    <link href="http://v2panda.com/2016/07/31/unit-tests/"/>
    <id>http://v2panda.com/2016/07/31/unit-tests/</id>
    <published>2016-07-31T03:22:13.000Z</published>
    <updated>2016-07-31T03:27:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>不写单元测试的程序员是不合格的，为了让自己成为一名合格的程序员，学习如何写单元测试是很有必要的，这里以Xcode集成的测试框架<a href="https://developer.apple.com/reference/xctest" target="_blank" rel="external">XCTest</a>为例。本文首先会介绍XCTest单元测试的基础用法，然后结合具体的实例分析，最后动手写一个单元测试。</p>
<a id="more"></a>
<h3 id="XCTest">XCTest</h3><h5 id="基础用法">基础用法</h5><p>默认的测试类继承自<code>XCTestCase</code>，当然也可以自定义测试类，添加一些公共的辅助方法。例如<code>AFNetworking</code>的所有测试用例类都有一个共同的父类<code>AFTestCase</code>，它是XCTestCase的子类，<code>AFNetworking</code>所有测试类都是AFTestCase类的子类，这块在后面会具体讲到。需要额外注意的是所有的测试方法都必须以<code>test</code>开头，且不能有参数，不然不会识别为测试方法，具体如下：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">DemoUnitTestsTests </span>: XCTestCase</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@implementation</span> DemoUnitTestsTests</span><br><span class="line"><span class="comment">// 在每一个测试用例开始前调用，用来初始化相关数据</span></span><br><span class="line">- (void)setUp &#123;</span><br><span class="line">    <span class="attr_selector">[super setUp]</span>;</span><br><span class="line">    <span class="comment">// Put setup code here. This method is called before the invocation of each test method in the class.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在测试用例完成后调用，可以用来释放变量等结尾操作</span></span><br><span class="line">- (void)tearDown &#123;</span><br><span class="line">    <span class="comment">// Put teardown code here. This method is called after the invocation of each test method in the class.</span></span><br><span class="line">    <span class="attr_selector">[super tearDown]</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试方法  </span></span><br><span class="line">- (void)testExample &#123;</span><br><span class="line">    <span class="comment">// This is an example of a functional test case.</span></span><br><span class="line">    <span class="comment">// Use XCTAssert and related functions to verify your tests produce the correct results.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 性能测试方法，通过测试block中方法执行的时间，比对设定的标准值和偏差觉得是否可以通过测试</span></span><br><span class="line">- (void)testPerformanceExample &#123;</span><br><span class="line">    <span class="comment">// This is an example of a performance test case.</span></span><br><span class="line">    <span class="attr_selector">[self measureBlock:^&#123;</span><br><span class="line">        // Put the code you want to measure the time of here.</span><br><span class="line">    &#125;]</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<h5 id="断言">断言</h5><p>XCTest的断言具体可查阅<code>XCTestAssertions.h</code>文件，这里还是做个简单的总结</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用断言</span></span><br><span class="line"><span class="function"><span class="title">XCTFail</span><span class="params">(format…)</span></span></span><br><span class="line"><span class="comment">//为空判断，a1为空时通过，反之不通过；</span></span><br><span class="line"><span class="function"><span class="title">XCTAssertNil</span><span class="params">(a1, format...)</span></span></span><br><span class="line"><span class="comment">//不为空判断，a1不为空时通过，反之不通过；</span></span><br><span class="line"><span class="function"><span class="title">XCTAssertNotNil</span><span class="params">(a1, format…)</span></span></span><br><span class="line"><span class="comment">//当expression求值为TRUE时通过；</span></span><br><span class="line"><span class="function"><span class="title">XCTAssert</span><span class="params">(expression, format...)</span></span> </span><br><span class="line"><span class="comment">//当expression求值为TRUE时通过；</span></span><br><span class="line"><span class="function"><span class="title">XCTAssertTrue</span><span class="params">(expression, format...)</span></span> </span><br><span class="line"><span class="comment">//当expression求值为False时通过；</span></span><br><span class="line"><span class="function"><span class="title">XCTAssertFalse</span><span class="params">(expression, format...)</span></span> </span><br><span class="line"><span class="comment">//判断相等，[a1 isEqual:a2]值为TRUE时通过，其中一个不为空时，不通过；</span></span><br><span class="line"><span class="function"><span class="title">XCTAssertEqualObjects</span><span class="params">(a1, a2, format...)</span></span> </span><br><span class="line"><span class="comment">//判断不等，[a1 isEqual:a2]值为False时通过；</span></span><br><span class="line"><span class="function"><span class="title">XCTAssertNotEqualObjects</span><span class="params">(a1, a2, format...)</span></span> </span><br><span class="line"><span class="comment">//判断相等（当a1和a2是 C语言标量、结构体或联合体时使用,实际测试发现NSString也可以）；</span></span><br><span class="line"><span class="function"><span class="title">XCTAssertEqual</span><span class="params">(a1, a2, format...)</span></span> </span><br><span class="line"><span class="comment">//判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；</span></span><br><span class="line"><span class="function"><span class="title">XCTAssertNotEqual</span><span class="params">(a1, a2, format...)</span></span> </span><br><span class="line"><span class="comment">//判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/-accuracy）以内相等时通过测试；</span></span><br><span class="line"><span class="function"><span class="title">XCTAssertEqualWithAccuracy</span><span class="params">(a1, a2, accuracy, format...)</span></span> </span><br><span class="line"><span class="comment">//判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试；</span></span><br><span class="line"><span class="function"><span class="title">XCTAssertNotEqualWithAccuracy</span><span class="params">(a1, a2, accuracy, format...)</span></span> </span><br><span class="line"><span class="comment">//异常测试，当expression发生异常时通过，反之不通过；</span></span><br><span class="line"><span class="function"><span class="title">XCTAssertThrows</span><span class="params">(expression, format...)</span></span> </span><br><span class="line"><span class="comment">//异常测试，当expression发生specificException异常时通过；反之发生其他异常或不发生异常均不通过</span></span><br><span class="line"><span class="function"><span class="title">XCTAssertThrowsSpecific</span><span class="params">(expression, specificException, format...)</span></span> </span><br><span class="line"><span class="comment">//异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过；</span></span><br><span class="line"><span class="function"><span class="title">XCTAssertThrowsSpecificNamed</span><span class="params">(expression, specificException, exception_name, format...)</span></span> </span><br><span class="line"><span class="comment">//异常测试，当expression没有发生异常时通过测试；</span></span><br><span class="line"><span class="function"><span class="title">XCTAssertNoThrow</span><span class="params">(expression, format…)</span></span> </span><br><span class="line"><span class="comment">//异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过；</span></span><br><span class="line"><span class="function"><span class="title">XCTAssertNoThrowSpecific</span><span class="params">(expression, specificException, format...)</span></span> </span><br><span class="line"><span class="comment">//异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过</span></span><br><span class="line"><span class="function"><span class="title">XCTAssertNoThrowSpecificNamed</span><span class="params">(expression, specificException, exception_name, format...)</span></span></span><br></pre></td></tr></table></figure>
<p>当然在有些特殊情况下直接使用这些断言，会让代码看起来很臃肿，比如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">XCTAssertTrue</span>(<span class="attr_selector">[string isKindOfClass:[NSString class]</span>] &amp;&amp; (<span class="attr_selector">[[NSUUID alloc]</span> <span class="rule"><span class="attribute">initWithUUIDString</span>:<span class="value">string] != nil), @<span class="string">"'%@' is not a valid UUID string"</span>, string)</span></span>;</span><br></pre></td></tr></table></figure>
<p>我们可以自定义断言宏来解决这个问题：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define AssertIsValidUUIDString(a1) \ <span class="keyword">do</span> &#123; \ NSUUID *_u = ([a1 isKindOfClass:[NSString <span class="class"><span class="keyword">class</span>]] ? [[<span class="title">NSUUID</span> <span class="title">alloc</span>] <span class="title">initWithUUIDString</span>:<span class="typename"></span></span>(a1)] : nil); \ <span class="keyword">if</span> (_u == nil) &#123; \ XCTFail(@<span class="string">"'%@' is not a valid UUID string"</span>, a1); \ &#125; \ &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>使用时只需要调用<code>AssertIsValidUUIDString(string)</code>即可，更多的封装：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hexcolor">#def</span>ine <span class="function"><span class="title">assertTrue</span><span class="params">(expr)</span></span> <span class="function"><span class="title">XCTAssertTrue</span><span class="params">((expr)</span></span>, @<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"><span class="hexcolor">#def</span>ine <span class="function"><span class="title">assertFalse</span><span class="params">(expr)</span></span> <span class="function"><span class="title">XCTAssertFalse</span><span class="params">((expr)</span></span>, @<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"><span class="hexcolor">#def</span>ine <span class="function"><span class="title">assertNil</span><span class="params">(a1)</span></span> <span class="function"><span class="title">XCTAssertNil</span><span class="params">((a1)</span></span>, @<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"><span class="hexcolor">#def</span>ine <span class="function"><span class="title">assertNotNil</span><span class="params">(a1)</span></span> <span class="function"><span class="title">XCTAssertNotNil</span><span class="params">((a1)</span></span>, @<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"><span class="hexcolor">#def</span>ine <span class="function"><span class="title">assertEqual</span><span class="params">(a1, a2)</span></span> <span class="function"><span class="title">XCTAssertEqual</span><span class="params">((a1)</span></span>, (a2), @<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"><span class="hexcolor">#def</span>ine <span class="function"><span class="title">assertEqualObjects</span><span class="params">(a1, a2)</span></span> <span class="function"><span class="title">XCTAssertEqualObjects</span><span class="params">((a1)</span></span>, (a2), @<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"><span class="hexcolor">#def</span>ine <span class="function"><span class="title">assertNotEqual</span><span class="params">(a1, a2)</span></span> <span class="function"><span class="title">XCTAssertNotEqual</span><span class="params">((a1)</span></span>, (a2), @<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"><span class="hexcolor">#def</span>ine <span class="function"><span class="title">assertNotEqualObjects</span><span class="params">(a1, a2)</span></span> <span class="function"><span class="title">XCTAssertNotEqualObjects</span><span class="params">((a1)</span></span>, (a2), @<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"><span class="hexcolor">#def</span>ine <span class="function"><span class="title">assertAccuracy</span><span class="params">(a1, a2, acc)</span></span> <span class="function"><span class="title">XCTAssertEqualWithAccuracy</span><span class="params">((a1)</span></span>,(a2),(acc))</span><br></pre></td></tr></table></figure>
<h5 id="期望">期望</h5><p>期望实际上是异步测试，当测试异步方法时，因为结果并不是立刻获得，所以我们可以设置一个期望，期望是有时间限定的的，fulfill表示满足期望。<br>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testAsynExample &#123; </span><br><span class="line">  XCTestExpectation *<span class="built_in">exp</span> = [self expectationWithDescription:@<span class="string">"这里可以是操作出错的原因描述。。。"</span>]; </span><br><span class="line">  NSOperationQueue *<span class="built_in">queue</span> = [[NSOperationQueue alloc]init]; </span><br><span class="line">  [<span class="built_in">queue</span> addOperationWithBlock:^&#123;</span><br><span class="line"> <span class="comment">//模拟这个异步操作需要2秒后才能获取结果，比如一个异步网络请求 </span></span><br><span class="line">  sleep(<span class="number">2</span>); </span><br><span class="line"><span class="comment">//模拟获取的异步操作后，获取结果，判断异步方法的结果是否正确</span></span><br><span class="line">   XCTAssertEqual(@<span class="string">"a"</span>, @<span class="string">"a"</span>); </span><br><span class="line"><span class="comment">//如果断言没问题，就调用fulfill宣布测试满足 </span></span><br><span class="line">  [<span class="built_in">exp</span> fulfill]; </span><br><span class="line">  &#125;]; </span><br><span class="line"><span class="comment">//设置延迟多少秒后，如果没有满足测试条件就报错</span></span><br><span class="line"> [self waitForExpectationsWithTimeout:<span class="number">3</span> handler:^(NSError * _Nullable error) &#123;</span><br><span class="line">   <span class="keyword">if</span> (error) &#123; </span><br><span class="line">      NSLog(@<span class="string">"Timeout Error: %@"</span>, error); </span><br><span class="line">    &#125;</span><br><span class="line"> &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异步测试除了使用 <code>expectationWithDescription</code>以外，还可以使用 <code>expectationForPredicate</code>和<code>expectationForNotification</code>,具体的可以看看<a href="http://liuyanwei.jumppo.com/2016/03/10/iOS-unit-test.html" target="_blank" rel="external">这里</a>。</p>
<h3 id="实例分析">实例分析</h3><p>这里以<code>AFNetworking</code>为例，前面提到了<code>AFNetworking</code>的所有测试用例类都有一个共同的父类<code>AFTestCase</code>，它也是<code>XCTestCase</code>的子类。在这个类中，添加了一些熟悉和公共方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;XCTest/XCTest.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> AFNetworkingTestsBaseURLString;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFTestCase</span> : <span class="title">XCTestCase</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  默认 https://httpbin.org/ 一个http库测试工具</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSURL</span> *baseURL;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSTimeInterval</span> networkTimeout;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)waitForExpectationsWithCommonTimeoutUsingHandler:(XCWaitCompletionHandler)handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>这里有两个属性，一个方法，<code>baseURL</code>不用说是测试地址。<code>networkTimeout</code>是网络请求超时时间，<code>waitForExpectationsWithCommonTimeoutUsingHandler</code>是超时后的方法捕获回调，那么什么时候调用这个方法呢，举个例子：<br>在Xcode 6之前的版本里面并没有内置XCTest，想使用异步测试的只能是在主线程的RunLoop里面使用一个while循环,然后一直等待响应或者直到timeout：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testAsync &#123;</span><br><span class="line">        <span class="built_in">NSDate</span> *timeoutDate = [<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">5.0</span>];</span><br><span class="line">        __block <span class="built_in">BOOL</span> responseHasArrived = <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">        [<span class="keyword">self</span> requestUrl:<span class="string">@"http://httpbin.com"</span></span><br><span class="line">                  completionHandler:^(<span class="built_in">NSString</span> *info) &#123;</span><br><span class="line">                  </span><br><span class="line">            responseHasArrived = <span class="literal">YES</span>;</span><br><span class="line">            XCTAssert(info<span class="variable">.length</span> &gt; <span class="number">0</span>);</span><br><span class="line">        &#125;];</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span> (responseHasArrived == <span class="literal">NO</span> &amp;&amp; ([timeoutDate timeIntervalSinceNow] &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">// 启动runloop，设置RunLoop最大时间（假无限循环），执行完毕是否退出</span></span><br><span class="line">            <span class="built_in">CFRunLoopRunInMode</span>(k<span class="built_in">CFRunLoopDefaultMode</span>, <span class="number">0.01</span>, <span class="literal">YES</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (responseHasArrived == <span class="literal">NO</span>) &#123;</span><br><span class="line">            XCTFail(<span class="string">@"Test timed out"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>while循环在主线程里面每隔0.01秒会跑一次，直到有响应或者5秒之后超出响应时间限制才会跳出。<br>而使用XCTest的测试期望来实现这个，测试框架就会预计它在之后的某一时刻被实现。最终的程序完成代码块中的测试代码会调用<code>XCTestExpection</code>类中的<code>fulfill</code>方法来实现期望。这一方法替代了我们之前例子里面使用<code>responseHasArrived</code>作为Flag的方式，这时我们让测试框架等待(有时限)测试期望通过XCTestCase的<code>waitForExpectationsWithTimeout:handler:</code>方法实现。如果完成处理的代码在指定时限里执行并调用了<code>fulfill</code>方法，那么就说明所有的测试期望在此期间都已经被实现。如:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testAsync &#123;</span><br><span class="line">  XCTestExpectation *expectation =</span><br><span class="line">  [<span class="keyword">self</span> expectationWithDescription:<span class="string">@"High Expectations"</span>];</span><br><span class="line">  [<span class="keyword">self</span><span class="variable">.pageLoader</span> requestUrl:<span class="string">@"http://httpbin.com"</span></span><br><span class="line">                  completionHandler:^(<span class="built_in">NSString</span> *info) &#123;</span><br><span class="line">                  </span><br><span class="line">            XCTAssert(info<span class="variable">.length</span> &gt; <span class="number">0</span>);</span><br><span class="line">            [expectation fulfill];</span><br><span class="line">        &#125;];</span><br><span class="line">    </span><br><span class="line">        [<span class="keyword">self</span> waitForExpectationsWithTimeout:<span class="number">5.0</span> handler:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">            <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"Timeout Error: %@"</span>, error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在最后的代码段里面使用<code>[expectation fulfill]</code>来告知此次测试所期望的部分已经确切实现过了。然后用<code>waitForExpectationsWithTimeout:handler</code>方法等待响应，这段会在接受响应之后执行或者超时之后也会执行。</p>
<h3 id="实战">实战</h3><p>还是以<code>AFNetworking</code>为例，写一个测试网络请求的测试用例，这里用cocoapods导入<code>AFNetworking</code>，需要注意的是此时<code>AFNetworking</code>在单元测试里无法使用，需要手动配置路径，步骤为：</p>
<ul>
<li>1.复制Target(App) - Build Setting - Header Search Paths 的路径。</li>
<li>2.粘贴到Target(UnitTests) - Build Setting - Header - Search Paths里。</li>
<li>3.复制Target(App) - Build Setting - User-Defined - PODS_ROOT整条。</li>
<li>4.到Target(UnitTests) - Build Setting - User-Defined新建一条PODS_ROOT。</li>
</ul>
<p>大部分网络请求都是异步操作，但是我们需要在主线程中获取到网络请求成功还是失败的信息。由于测试方法主线程执行完就会结束，所以需要设置一下，查看异步返回结果。这里我们使用期望在方法结束前设置等待，如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)testRequest&#123;</span><br><span class="line">    </span><br><span class="line">    XCTestExpectation *expectation =[<span class="keyword">self</span> expectationWithDescription:<span class="string">@"没有满足期望"</span>];</span><br><span class="line">    AFHTTPSessionManager *sessionManager = [AFHTTPSessionManager manager];</span><br><span class="line">    sessionManager<span class="variable">.responseSerializer</span> = [AFHTTPResponseSerializer serializer];</span><br><span class="line">    [sessionManager GET:<span class="string">@"http://www.weather.com.cn/adat/sk/101110101.html"</span> parameters:<span class="literal">nil</span> success:^(<span class="built_in">NSURLSessionDataTask</span> * _Nonnull task, <span class="keyword">id</span>  _Nullable responseObject) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"responseObject:%@"</span>, [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:responseObject options:<span class="number">1</span> error:<span class="literal">nil</span>]);</span><br><span class="line">        XCTAssertNotNil(responseObject, <span class="string">@"返回出错"</span>);</span><br><span class="line">        [expectation fulfill];</span><br><span class="line">    &#125; failure:^(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> * _Nonnull error) &#123;</span><br><span class="line">        XCTAssertNil(error, <span class="string">@"请求出错"</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">// 设置5秒的超时时间</span></span><br><span class="line">    [<span class="keyword">self</span> waitForExpectationsWithTimeout:<span class="number">5.0</span> handler:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Timeout Error: %@"</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相关的Demo在<a href="https://github.com/v2panda/PDSourceNotes/tree/master/AFNetworking/DemoUnitTests" target="_blank" rel="external">这里</a>。</p>
<h3 id="Reference">Reference</h3><p><a href="https://objccn.io/issue-15-2/" target="_blank" rel="external">XCTest测试实战</a></p>
<p><a href="http://liuyanwei.jumppo.com/2016/03/10/iOS-unit-test.html" target="_blank" rel="external">iOS单元测试</a></p>
<p><a href="http://www.jianshu.com/p/8bbec078cabe" target="_blank" rel="external">iOS单元测试(作用及入门提升)</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;&lt;p&gt;不写单元测试的程序员是不合格的，为了让自己成为一名合格的程序员，学习如何写单元测试是很有必要的，这里以Xcode集成的测试框架&lt;a href=&quot;https://developer.apple.com/reference/xctest&quot;&gt;XCTest&lt;/a&gt;为例。本文首先会介绍XCTest单元测试的基础用法，然后结合具体的实例分析，最后动手写一个单元测试。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SDWebImage源码阅读笔记</title>
    <link href="http://v2panda.com/2016/06/30/SDWebImage-notes/"/>
    <id>http://v2panda.com/2016/06/30/SDWebImage-notes/</id>
    <published>2016-06-30T01:51:07.000Z</published>
    <updated>2016-07-03T01:56:31.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><p><a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">SDWebImage</a>是一个图片加载库，目前在Github上已有将近14k的star了，这篇文章记录了阅读SDWebImage源码的笔记(Version 3.8)，简单的研究了它的实现细节。</p>
<h3 id="流程">流程</h3><p>SDWebImage加载图片的大致流程，以UIImageView+WebCache为例。</p>
<p>1.调用基础入口方法<br><code>sd_setImageWithURL:</code>,<code>sd_setImageWithURL:placeholderImage:</code>,<code>sd_setImageWithURL:placeholderImage:options:</code>等等</p>
<p>2.进入<code>sd_setImageWithURL:placeholderImage:options:progress:completed:</code></p>
<p>3.进入<code>downloadImageWithURL:options:progress:completed:</code></p>
<p>4.调用SDWebImageDownloader下载图片<code>downloadImageWithURL:options:progress:completed:</code></p>
<p>5.调用<code>addProgressCallback:completedBlock:forURL:createCallback:</code></p>
<p>6.初始化SDWebImageDownloaderOperation<br><code>initWithRequest:inSession:options:progress:completed:cancelled:</code></p>
<p>7.缓存图片调用<code>storeImage:recalculateFromImage:imageData:forKey:toDisk:</code></p>
<p>以上方法是调用链上的主要方法，将在下文逐一解释。</p>
<a id="more"></a>
<h3 id="Utils">Utils</h3><p>Utils有三个类：</p>
<ul>
<li><code>SDWebImageManager</code><br>SDWebImage核心类，用来管理图片的下载和缓存</li>
<li><code>SDWebImageDecoder</code><br>解压缩图片</li>
<li><code>SDWebImagePrefetcher</code><br>可以预先下载图片</li>
</ul>
<h5 id="SDWebImageManager">SDWebImageManager</h5><p>用来管理图片的下载和缓存工具类，提取了<code>SDImageCache</code>和<code>SDWebImageDownloader</code>的相关方法，在流程3中使用的方法具体为：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span> &lt;SDWebImageOperation&gt;)downloadImageWithURL:(<span class="built_in">NSURL</span> *)url</span><br><span class="line">                                         options:(SDWebImageOptions)options</span><br><span class="line">                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                       completed:(SDWebImageCompletionWithFinishedBlock)completedBlock &#123;</span><br><span class="line">    <span class="comment">// 没有completedBlock调用这个方法是毫无意义的</span></span><br><span class="line">    <span class="built_in">NSAssert</span>(completedBlock != <span class="literal">nil</span>, <span class="string">@"If you mean to prefetch the image, use -[SDWebImagePrefetcher prefetchURLs] instead"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断url合法性，并帮将NSString当NSURL的新手擦屁股</span></span><br><span class="line">    <span class="keyword">if</span> ([url isKindOfClass:<span class="built_in">NSString</span><span class="variable">.class</span>]) &#123;</span><br><span class="line">        url = [<span class="built_in">NSURL</span> URLWithString:(<span class="built_in">NSString</span> *)url];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断url合法性</span></span><br><span class="line">    <span class="keyword">if</span> (![url isKindOfClass:<span class="built_in">NSURL</span><span class="variable">.class</span>]) &#123;</span><br><span class="line">        url = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建SDWebImageCombinedOperation对象</span></span><br><span class="line">    __block SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];</span><br><span class="line">    __<span class="keyword">weak</span> SDWebImageCombinedOperation *weakOperation = operation;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BOOL</span> isFailedUrl = <span class="literal">NO</span>;</span><br><span class="line">    <span class="comment">// 给failedURLs属性加锁，确保同一时间只有一个线程操作</span></span><br><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span><span class="variable">.failedURLs</span>) &#123;</span><br><span class="line">        <span class="comment">// 检查url是否是下载失败的</span></span><br><span class="line">        isFailedUrl = [<span class="keyword">self</span><span class="variable">.failedURLs</span> containsObject:url];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查url的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (url<span class="variable">.absoluteString</span><span class="variable">.length</span> == <span class="number">0</span> || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) &#123;</span><br><span class="line">        dispatch_main_sync_safe(^&#123;</span><br><span class="line">            <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="built_in">NSURLErrorFileDoesNotExist</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">            completedBlock(<span class="literal">nil</span>, error, SDImageCacheTypeNone, <span class="literal">YES</span>, url);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> operation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span><span class="variable">.runningOperations</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.runningOperations</span> addObject:operation];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 默认使用url作key，也可以自定义cacheKeyFilter过滤</span></span><br><span class="line">    <span class="built_in">NSString</span> *key = [<span class="keyword">self</span> cacheKeyForURL:url];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找内存或硬盘中是否有缓存的图片</span></span><br><span class="line">    operation<span class="variable">.cacheOperation</span> = [<span class="keyword">self</span><span class="variable">.imageCache</span> queryDiskCacheForKey:key done:^(<span class="built_in">UIImage</span> *image, SDImageCacheType cacheType) &#123;</span><br><span class="line">        <span class="keyword">if</span> (operation<span class="variable">.isCancelled</span>) &#123;</span><br><span class="line">            <span class="keyword">@synchronized</span> (<span class="keyword">self</span><span class="variable">.runningOperations</span>) &#123;</span><br><span class="line">                [<span class="keyword">self</span><span class="variable">.runningOperations</span> removeObject:operation];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((!image || options &amp; SDWebImageRefreshCached) &amp;&amp; (![<span class="keyword">self</span><span class="variable">.delegate</span> respondsToSelector:<span class="keyword">@selector</span>(imageManager:shouldDownloadImageForURL:)] || [<span class="keyword">self</span><span class="variable">.delegate</span> imageManager:<span class="keyword">self</span> shouldDownloadImageForURL:url])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (image &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span><br><span class="line">                dispatch_main_sync_safe(^&#123;</span><br><span class="line">                    <span class="comment">// 如果图片存在，但采用SDWebImageRefreshCached标记，通知获取到了图片，并再次从网络下载，使NSURLCache重新刷新</span></span><br><span class="line">                    completedBlock(image, <span class="literal">nil</span>, cacheType, <span class="literal">YES</span>, url);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下载图片</span></span><br><span class="line">            <span class="comment">// SDWebImageOptions和SDWebImageDownloaderOptions对应关系</span></span><br><span class="line">            <span class="comment">// a |= b     ------&gt;   a = a | b</span></span><br><span class="line">            SDWebImageDownloaderOptions downloaderOptions = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (options &amp; SDWebImageLowPriority) downloaderOptions |= SDWebImageDownloaderLowPriority;</span><br><span class="line">            <span class="keyword">if</span> (options &amp; SDWebImageProgressiveDownload) downloaderOptions |= SDWebImageDownloaderProgressiveDownload;</span><br><span class="line">            <span class="keyword">if</span> (options &amp; SDWebImageRefreshCached) downloaderOptions |= SDWebImageDownloaderUse<span class="built_in">NSURLCache</span>;</span><br><span class="line">            <span class="keyword">if</span> (options &amp; SDWebImageContinueInBackground) downloaderOptions |= SDWebImageDownloaderContinueInBackground;</span><br><span class="line">            <span class="keyword">if</span> (options &amp; SDWebImageHandleCookies) downloaderOptions |= SDWebImageDownloaderHandleCookies;</span><br><span class="line">            <span class="keyword">if</span> (options &amp; SDWebImageAllowInvalidSSLCertificates) downloaderOptions |= SDWebImageDownloaderAllowInvalidSSLCertificates;</span><br><span class="line">            <span class="keyword">if</span> (options &amp; SDWebImageHighPriority) downloaderOptions |= SDWebImageDownloaderHighPriority;</span><br><span class="line">            <span class="keyword">if</span> (image &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span><br><span class="line">                <span class="comment">// force progressive off if image already cached but forced refreshing</span></span><br><span class="line">                <span class="comment">// ~ 按位取反运算符</span></span><br><span class="line">                downloaderOptions &amp;= ~SDWebImageDownloaderProgressiveDownload;</span><br><span class="line">                <span class="comment">// ignore image read from NSURLCache if image if cached but force refreshing</span></span><br><span class="line">                downloaderOptions |= SDWebImageDownloaderIgnoreCachedResponse;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 调用SDWebImageDownloader下载图片</span></span><br><span class="line">            <span class="keyword">id</span> &lt;SDWebImageOperation&gt; subOperation = [<span class="keyword">self</span><span class="variable">.imageDownloader</span> downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(<span class="built_in">UIImage</span> *downloadedImage, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, <span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">                __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</span><br><span class="line">                <span class="keyword">if</span> (!strongOperation || strongOperation<span class="variable">.isCancelled</span>) &#123;</span><br><span class="line">                    <span class="comment">// Do nothing if the operation was cancelled</span></span><br><span class="line">                    <span class="comment">// See #699 for more details</span></span><br><span class="line">                    <span class="comment">// if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                    dispatch_main_sync_safe(^&#123;</span><br><span class="line">                        <span class="keyword">if</span> (strongOperation &amp;&amp; !strongOperation<span class="variable">.isCancelled</span>) &#123;</span><br><span class="line">                            completedBlock(<span class="literal">nil</span>, error, SDImageCacheTypeNone, finished, url);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (   error<span class="variable">.code</span> != <span class="built_in">NSURLErrorNotConnectedToInternet</span></span><br><span class="line">                        &amp;&amp; error<span class="variable">.code</span> != <span class="built_in">NSURLErrorCancelled</span></span><br><span class="line">                        &amp;&amp; error<span class="variable">.code</span> != <span class="built_in">NSURLErrorTimedOut</span></span><br><span class="line">                        &amp;&amp; error<span class="variable">.code</span> != <span class="built_in">NSURLErrorInternationalRoamingOff</span></span><br><span class="line">                        &amp;&amp; error<span class="variable">.code</span> != <span class="built_in">NSURLErrorDataNotAllowed</span></span><br><span class="line">                        &amp;&amp; error<span class="variable">.code</span> != <span class="built_in">NSURLErrorCannotFindHost</span></span><br><span class="line">                        &amp;&amp; error<span class="variable">.code</span> != <span class="built_in">NSURLErrorCannotConnectToHost</span>) &#123;</span><br><span class="line">                        <span class="comment">// 下载失败，将url添加到失败urls里</span></span><br><span class="line">                        <span class="keyword">@synchronized</span> (<span class="keyword">self</span><span class="variable">.failedURLs</span>) &#123;</span><br><span class="line">                            [<span class="keyword">self</span><span class="variable">.failedURLs</span> addObject:url];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 下载失败，但选择了标记SDWebImageRetryFailed，移除失败url</span></span><br><span class="line">                    <span class="keyword">if</span> ((options &amp; SDWebImageRetryFailed)) &#123;</span><br><span class="line">                        <span class="keyword">@synchronized</span> (<span class="keyword">self</span><span class="variable">.failedURLs</span>) &#123;</span><br><span class="line">                            [<span class="keyword">self</span><span class="variable">.failedURLs</span> removeObject:url];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="built_in">BOOL</span> cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (options &amp; SDWebImageRefreshCached &amp;&amp; image &amp;&amp; !downloadedImage) &#123;</span><br><span class="line">                        <span class="comment">// Image refresh hit the NSURLCache cache, do not call the completion block</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (downloadedImage &amp;&amp; (!downloadedImage<span class="variable">.images</span> || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [<span class="keyword">self</span><span class="variable">.delegate</span> respondsToSelector:<span class="keyword">@selector</span>(imageManager:transformDownloadedImage:withURL:)]) &#123;</span><br><span class="line">                        <span class="comment">// 在全局队列中调用，以不阻塞主线程</span></span><br><span class="line">                        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</span><br><span class="line">                            <span class="comment">// 在下载完后，缓存到内存或硬盘之前，做转换图片操作</span></span><br><span class="line">                            <span class="built_in">UIImage</span> *transformedImage = [<span class="keyword">self</span><span class="variable">.delegate</span> imageManager:<span class="keyword">self</span> transformDownloadedImage:downloadedImage withURL:url];</span><br><span class="line">                            <span class="comment">// 将转换完的图片缓存</span></span><br><span class="line">                            <span class="keyword">if</span> (transformedImage &amp;&amp; finished) &#123;</span><br><span class="line">                                <span class="built_in">BOOL</span> imageWasTransformed = ![transformedImage isEqual:downloadedImage];</span><br><span class="line">                                [<span class="keyword">self</span><span class="variable">.imageCache</span> storeImage:transformedImage recalculateFromImage:imageWasTransformed imageData:(imageWasTransformed ? <span class="literal">nil</span> : data) forKey:key toDisk:cacheOnDisk];</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                                <span class="keyword">if</span> (strongOperation &amp;&amp; !strongOperation<span class="variable">.isCancelled</span>) &#123;</span><br><span class="line">                                    completedBlock(transformedImage, <span class="literal">nil</span>, SDImageCacheTypeNone, finished, url);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 将转换完的图片缓存</span></span><br><span class="line">                        <span class="keyword">if</span> (downloadedImage &amp;&amp; finished) &#123;</span><br><span class="line">                            [<span class="keyword">self</span><span class="variable">.imageCache</span> storeImage:downloadedImage recalculateFromImage:<span class="literal">NO</span> imageData:data forKey:key toDisk:cacheOnDisk];</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        dispatch_main_sync_safe(^&#123;</span><br><span class="line">                            <span class="keyword">if</span> (strongOperation &amp;&amp; !strongOperation<span class="variable">.isCancelled</span>) &#123;</span><br><span class="line">                                completedBlock(downloadedImage, <span class="literal">nil</span>, SDImageCacheTypeNone, finished, url);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">                    <span class="keyword">@synchronized</span> (<span class="keyword">self</span><span class="variable">.runningOperations</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (strongOperation) &#123;</span><br><span class="line">                            [<span class="keyword">self</span><span class="variable">.runningOperations</span> removeObject:strongOperation];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">            operation<span class="variable">.cancelBlock</span> = ^&#123;</span><br><span class="line">                [subOperation cancel];</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">@synchronized</span> (<span class="keyword">self</span><span class="variable">.runningOperations</span>) &#123;</span><br><span class="line">                    __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</span><br><span class="line">                    <span class="keyword">if</span> (strongOperation) &#123;</span><br><span class="line">                        [<span class="keyword">self</span><span class="variable">.runningOperations</span> removeObject:strongOperation];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (image) &#123; <span class="comment">// 图片存在，即内存或硬盘中有图片</span></span><br><span class="line">            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</span><br><span class="line">                <span class="keyword">if</span> (strongOperation &amp;&amp; !strongOperation<span class="variable">.isCancelled</span>) &#123;</span><br><span class="line">                    <span class="comment">//  返回image和cacheType</span></span><br><span class="line">                    completedBlock(image, <span class="literal">nil</span>, cacheType, <span class="literal">YES</span>, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 删除当前operation</span></span><br><span class="line">            <span class="keyword">@synchronized</span> (<span class="keyword">self</span><span class="variable">.runningOperations</span>) &#123;</span><br><span class="line">                [<span class="keyword">self</span><span class="variable">.runningOperations</span> removeObject:operation];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Image not in cache and download disallowed by delegate</span></span><br><span class="line">            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</span><br><span class="line">                <span class="keyword">if</span> (strongOperation &amp;&amp; !weakOperation<span class="variable">.isCancelled</span>) &#123;</span><br><span class="line">                    completedBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, SDImageCacheTypeNone, <span class="literal">YES</span>, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">@synchronized</span> (<span class="keyword">self</span><span class="variable">.runningOperations</span>) &#123;</span><br><span class="line">                [<span class="keyword">self</span><span class="variable">.runningOperations</span> removeObject:operation];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此为核心方法，完成了查找缓存、下载图片、缓存图片等操作。值得注意的是SDWebImageManager还有一个delegate属性，并提供了两个可选方法:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">SDWebImageManagerDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)imageManager:(SDWebImageManager *)imageManager shouldDownloadImageForURL:(<span class="built_in">NSURL</span> *)imageURL;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在下载完后，缓存到内存或硬盘之前，做转换图片操作</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)imageManager:(SDWebImageManager *)imageManager transformDownloadedImage:(<span class="built_in">UIImage</span> *)image withURL:(<span class="built_in">NSURL</span> *)imageURL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h5 id="SDWebImageDecoder">SDWebImageDecoder</h5><p>用来解压缩图片，会在取图片时做一次decode操作。<br>因为通过 imageNamed 创建 UIImage 时，系统实际上只是在 Bundle 内查找到文件名，然后把这个文件名放到 UIImage 里返回，并没有进行实际的文件读取和解码。当 UIImage 第一次显示到屏幕上时，其内部的解码方法才会被调用，同时解码结果会保存到一个全局缓存去。在图片解码后，App 第一次退到后台和收到内存警告时，该图片的缓存才会被清空，其他情况下缓存会一直存在。具体的说就是一个UIImage加载了jpeg或者png，当UIImageView将要显示这个UIImage的时候会先把png和jpeg解码成未压缩格式，所以SDWebImage有一个decodeImage方法，就是把这一步放在了异步线程做，防止tableViewCell中的imageView加载图片的时候在主线程解码图片，导致滑动卡顿。这样效率很低，但是只有瞬时的内存需求。为了提高效率通过SDWebImageDecoder将包装在Data下的资源解压，然后画在另外一张图片上，这样这张新图片就不再需要重复解压了,这种做法是典型的空间换时间的做法，如下从硬盘中去图片时，分别对图片进行了缩放和解压缩操作。<br>关于处理图片可以看看YY这篇<a href="http://blog.ibireme.com/2015/11/02/ios_image_tips/" target="_blank" rel="external">博文</a></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)diskImageForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="built_in">NSData</span> *data = [<span class="keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> sd_imageWithData:data];</span><br><span class="line">        <span class="comment">// 缩放图片</span></span><br><span class="line">        image = [<span class="keyword">self</span> scaledImageForKey:key image:image];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.shouldDecompressImages</span>) &#123;</span><br><span class="line">            <span class="comment">// 解压缩</span></span><br><span class="line">            image = [<span class="built_in">UIImage</span> decodedImageWithImage:image];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DownLoader">DownLoader</h3><p>DownLoader有两个类：</p>
<ul>
<li><code>SDWebImageDownloader</code><br>下载核心类，用来管理图片的下载</li>
<li><code>SDWebImageDownloaderOperation</code><br>每一个图片下载的具体操作</li>
</ul>
<h5 id="SDWebImageDownloader">SDWebImageDownloader</h5><p><code>SDWebImageDownloader</code>一个单例类,负责图片的下载操作和管理,其在流程4和流程5中的主要方法为：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span> &lt;SDWebImageOperation&gt;)downloadImageWithURL:(<span class="built_in">NSURL</span> *)url options:(SDWebImageDownloaderOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageDownloaderCompletedBlock)completedBlock &#123;</span><br><span class="line">    __block SDWebImageDownloaderOperation *operation;</span><br><span class="line">    __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)wself = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^&#123;</span><br><span class="line">        <span class="comment">// 过期时间</span></span><br><span class="line">        <span class="built_in">NSTimeInterval</span> timeoutInterval = wself<span class="variable">.downloadTimeout</span>;</span><br><span class="line">        <span class="keyword">if</span> (timeoutInterval == <span class="number">0.0</span>) &#123;</span><br><span class="line">            timeoutInterval = <span class="number">15.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建请求对象，并根据options参数设置其属性</span></span><br><span class="line">        <span class="comment">// 为了避免潜在的重复缓存(NSURLCache + SDImageCache)，如果没有明确告知需要缓存，则禁用图片请求的缓存操作</span></span><br><span class="line">        <span class="built_in">NSMutableURLRequest</span> *request = [[<span class="built_in">NSMutableURLRequest</span> alloc] initWithURL:url cachePolicy:(options &amp; SDWebImageDownloaderUse<span class="built_in">NSURLCache</span> ? <span class="built_in">NSURLRequestUseProtocolCachePolicy</span> : <span class="built_in">NSURLRequestReloadIgnoringLocalCacheData</span>) timeoutInterval:timeoutInterval];</span><br><span class="line">        request<span class="variable">.HTTPShouldHandleCookies</span> = (options &amp; SDWebImageDownloaderHandleCookies);</span><br><span class="line">        request<span class="variable">.HTTPShouldUsePipelining</span> = <span class="literal">YES</span>;</span><br><span class="line">        <span class="comment">// header过滤</span></span><br><span class="line">        <span class="keyword">if</span> (wself<span class="variable">.headersFilter</span>) &#123;</span><br><span class="line">            request<span class="variable">.allHTTPHeaderFields</span> = wself<span class="variable">.headersFilter</span>(url, [wself<span class="variable">.HTTPHeaders</span> <span class="keyword">copy</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            request<span class="variable">.allHTTPHeaderFields</span> = wself<span class="variable">.HTTPHeaders</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化SDWebImageDownloaderOperation</span></span><br><span class="line">        operation = [[wself<span class="variable">.operationClass</span> alloc] initWithRequest:request</span><br><span class="line">                                                        inSession:<span class="keyword">self</span><span class="variable">.session</span></span><br><span class="line">                                                          options:options</span><br><span class="line">                                                         progress:^(<span class="built_in">NSInteger</span> receivedSize, <span class="built_in">NSInteger</span> expectedSize) &#123;</span><br><span class="line">                                                             SDWebImageDownloader *sself = wself;</span><br><span class="line">                                                             <span class="keyword">if</span> (!sself) <span class="keyword">return</span>;</span><br><span class="line">                                                             __block <span class="built_in">NSArray</span> *callbacksForURL;</span><br><span class="line">                                                             <span class="built_in">dispatch_sync</span>(sself<span class="variable">.barrierQueue</span>, ^&#123;</span><br><span class="line">                                                                 callbacksForURL = [sself<span class="variable">.URLCallbacks</span>[url] <span class="keyword">copy</span>];</span><br><span class="line">                                                             &#125;);</span><br><span class="line">                                                             <span class="comment">// 从URLCallbacks取出progress回调</span></span><br><span class="line">                                                             <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *callbacks <span class="keyword">in</span> callbacksForURL) &#123;</span><br><span class="line">                                                                 <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                                                                     SDWebImageDownloaderProgressBlock callback = callbacks[kProgressCallbackKey];</span><br><span class="line">                                                                     <span class="keyword">if</span> (callback) callback(receivedSize, expectedSize);</span><br><span class="line">                                                                 &#125;);</span><br><span class="line">                                                             &#125;</span><br><span class="line">                                                         &#125;</span><br><span class="line">                                                        completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, <span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">                                                            SDWebImageDownloader *sself = wself;</span><br><span class="line">                                                            <span class="keyword">if</span> (!sself) <span class="keyword">return</span>;</span><br><span class="line">                                                            __block <span class="built_in">NSArray</span> *callbacksForURL;</span><br><span class="line">                                                            dispatch_barrier_sync(sself<span class="variable">.barrierQueue</span>, ^&#123;</span><br><span class="line">                                                                callbacksForURL = [sself<span class="variable">.URLCallbacks</span>[url] <span class="keyword">copy</span>];</span><br><span class="line">                                                                <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">                                                                    [sself<span class="variable">.URLCallbacks</span> removeObjectForKey:url];</span><br><span class="line">                                                                &#125;</span><br><span class="line">                                                            &#125;);</span><br><span class="line">                                                            <span class="comment">// 从URLCallbacks取出complete回调</span></span><br><span class="line">                                                            <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *callbacks <span class="keyword">in</span> callbacksForURL) &#123;</span><br><span class="line">                                                                SDWebImageDownloaderCompletedBlock callback = callbacks[kCompletedCallbackKey];</span><br><span class="line">                                                                <span class="keyword">if</span> (callback) callback(image, data, error, finished);</span><br><span class="line">                                                            &#125;</span><br><span class="line">                                                        &#125;</span><br><span class="line">                                                        cancelled:^&#123;</span><br><span class="line">                                                            SDWebImageDownloader *sself = wself;</span><br><span class="line">                                                            <span class="keyword">if</span> (!sself) <span class="keyword">return</span>;</span><br><span class="line">                                                            dispatch_barrier_async(sself<span class="variable">.barrierQueue</span>, ^&#123;</span><br><span class="line">                                                                [sself<span class="variable">.URLCallbacks</span> removeObjectForKey:url];</span><br><span class="line">                                                            &#125;);</span><br><span class="line">                                                        &#125;];</span><br><span class="line">        <span class="comment">// 对图片进行解压缩，默认为YES</span></span><br><span class="line">        operation<span class="variable">.shouldDecompressImages</span> = wself<span class="variable">.shouldDecompressImages</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (wself<span class="variable">.urlCredential</span>) &#123;</span><br><span class="line">            operation<span class="variable">.credential</span> = wself<span class="variable">.urlCredential</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wself<span class="variable">.username</span> &amp;&amp; wself<span class="variable">.password</span>) &#123;</span><br><span class="line">            operation<span class="variable">.credential</span> = [<span class="built_in">NSURLCredential</span> credentialWithUser:wself<span class="variable">.username</span> password:wself<span class="variable">.password</span> persistence:<span class="built_in">NSURLCredentialPersistenceForSession</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置优先级</span></span><br><span class="line">        <span class="keyword">if</span> (options &amp; SDWebImageDownloaderHighPriority) &#123;</span><br><span class="line">            operation<span class="variable">.queuePriority</span> = <span class="built_in">NSOperationQueuePriorityHigh</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options &amp; SDWebImageDownloaderLowPriority) &#123;</span><br><span class="line">            operation<span class="variable">.queuePriority</span> = <span class="built_in">NSOperationQueuePriorityLow</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将操作加入到操作队列downloadQueue中</span></span><br><span class="line">        [wself<span class="variable">.downloadQueue</span> addOperation:operation];</span><br><span class="line">        <span class="comment">// 如果是LIFO顺序，则将新的操作作为原队列中最后一个操作的依赖，然后将新操作设置为最后一个操作</span></span><br><span class="line">        <span class="keyword">if</span> (wself<span class="variable">.executionOrder</span> == SDWebImageDownloaderLIFOExecutionOrder) &#123;</span><br><span class="line">            <span class="comment">// Emulate LIFO execution order by systematically adding new operations as last operation's dependency</span></span><br><span class="line">            [wself<span class="variable">.lastAddedOperation</span> addDependency:operation];</span><br><span class="line">            wself<span class="variable">.lastAddedOperation</span> = operation;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> operation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock forURL:(<span class="built_in">NSURL</span> *)url createCallback:(SDWebImageNoParamsBlock)createCallback &#123;</span><br><span class="line">    <span class="comment">// The URL will be used as the key to the callbacks dictionary so it cannot be nil. If it is nil immediately call the completed block with no image or data.</span></span><br><span class="line">    <span class="keyword">if</span> (url == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (completedBlock != <span class="literal">nil</span>) &#123;</span><br><span class="line">            completedBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">NO</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以dispatch_barrier_sync操作来保证同一时间只有一个线程能对URLCallbacks进行操作</span></span><br><span class="line">    <span class="comment">// 为了保证URLCallbacks操作(添加、删除)的线程安全性，SDWebImageDownloader将这些操作作为一个个任务放到barrierQueue队列中，并设置屏障来确保同一时间只有一个线程操作URLCallbacks属性</span></span><br><span class="line">    dispatch_barrier_sync(<span class="keyword">self</span><span class="variable">.barrierQueue</span>, ^&#123;</span><br><span class="line">        <span class="built_in">BOOL</span> first = <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span><span class="variable">.URLCallbacks</span>[url]) &#123;</span><br><span class="line">            <span class="keyword">self</span><span class="variable">.URLCallbacks</span>[url] = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">            first = <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Handle single download of simultaneous download request for the same URL</span></span><br><span class="line">        <span class="comment">// 处理同一URL的同步下载请求的单个下载</span></span><br><span class="line">        <span class="built_in">NSMutableArray</span> *callbacksForURL = <span class="keyword">self</span><span class="variable">.URLCallbacks</span>[url];</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *callbacks = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">        <span class="keyword">if</span> (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock <span class="keyword">copy</span>];</span><br><span class="line">        <span class="keyword">if</span> (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock <span class="keyword">copy</span>];</span><br><span class="line">        [callbacksForURL addObject:callbacks];</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.URLCallbacks</span>[url] = callbacksForURL;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (first) &#123;</span><br><span class="line">            createCallback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是<code>SDWebImageDownloader</code>管理的下载是放在一个<code>NSOperationQueue</code>队列中来完成的，其中每个下载操作都是一个单独的<code>SDWebImageDownloaderOperation</code>，将这些操作放到一个操作队列中，这样可以实现图片的并发下载。</p>
<h5 id="SDWebImageDownloaderOperation">SDWebImageDownloaderOperation</h5><p><code>SDWebImageDownloaderOperation</code>继承自NSOperation，实际中每个图片的下载都交给一个<code>SDWebImageDownloaderOperation</code>，需要注意的是在SDWebImage Version3.8中，下载已经有原先的NSURLConnection切换到了NSURLSession了，所以我们要关注的是NSURLSessionDataDelegate中的<code>URLSession:dataTask:didReceiveResponse:completionHandler:</code>方法，此方法主要用来接收数据:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    <span class="comment">// 每次附加新数据</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.imageData</span> appendData:data];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span><span class="variable">.options</span> &amp; SDWebImageDownloaderProgressiveDownload) &amp;&amp; <span class="keyword">self</span><span class="variable">.expectedSize</span> &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">self</span><span class="variable">.completedBlock</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录当前总大小</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">NSInteger</span> totalSize = <span class="keyword">self</span><span class="variable">.imageData</span><span class="variable">.length</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每次接收到数据时，用现有的数据创建一个CGImageSourceRef对象</span></span><br><span class="line">        <span class="built_in">CGImageSourceRef</span> imageSource = <span class="built_in">CGImageSourceCreateWithData</span>((__bridge <span class="built_in">CFDataRef</span>)<span class="keyword">self</span><span class="variable">.imageData</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (width + height == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 从这些包含图像信息的数据中取出图像的长、宽、方向等信息以备使用</span></span><br><span class="line">            <span class="built_in">CFDictionaryRef</span> properties = <span class="built_in">CGImageSourceCopyPropertiesAtIndex</span>(imageSource, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (properties) &#123;</span><br><span class="line">                <span class="built_in">NSInteger</span> orientationValue = -<span class="number">1</span>;</span><br><span class="line">                <span class="built_in">CFTypeRef</span> val = <span class="built_in">CFDictionaryGetValue</span>(properties, k<span class="built_in">CGImagePropertyPixelHeight</span>);</span><br><span class="line">                <span class="keyword">if</span> (val) <span class="built_in">CFNumberGetValue</span>(val, k<span class="built_in">CFNumberLongType</span>, &amp;height);</span><br><span class="line">                val = <span class="built_in">CFDictionaryGetValue</span>(properties, k<span class="built_in">CGImagePropertyPixelWidth</span>);</span><br><span class="line">                <span class="keyword">if</span> (val) <span class="built_in">CFNumberGetValue</span>(val, k<span class="built_in">CFNumberLongType</span>, &amp;width);</span><br><span class="line">                val = <span class="built_in">CFDictionaryGetValue</span>(properties, k<span class="built_in">CGImagePropertyOrientation</span>);</span><br><span class="line">                <span class="keyword">if</span> (val) <span class="built_in">CFNumberGetValue</span>(val, k<span class="built_in">CFNumberNSIntegerType</span>, &amp;orientationValue);</span><br><span class="line">                <span class="built_in">CFRelease</span>(properties);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 绘制到Core Graphics时，会丢失方向信息，这意味着有时候由initWithCGIImage创建的图片</span></span><br><span class="line">                <span class="comment">//    的方向会不对，所以在这边先保存这个信息并在后面使用</span></span><br><span class="line">                orientation = [[<span class="keyword">self</span> class] orientationFromPropertyValue:(orientationValue == -<span class="number">1</span> ? <span class="number">1</span> : orientationValue)];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下载未完成</span></span><br><span class="line">        <span class="keyword">if</span> (width + height &gt; <span class="number">0</span> &amp;&amp; totalSize &lt; <span class="keyword">self</span><span class="variable">.expectedSize</span>) &#123;</span><br><span class="line">            <span class="comment">// Create the image</span></span><br><span class="line">            <span class="comment">// 使用现有的数据创建图片对象，如果数据中存有多张图片，则取第一张</span></span><br><span class="line">            <span class="built_in">CGImageRef</span> partialImageRef = <span class="built_in">CGImageSourceCreateImageAtIndex</span>(imageSource, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifdef TARGET_OS_IPHONE</span></span><br><span class="line">            <span class="comment">// Workaround for iOS anamorphic image</span></span><br><span class="line">            <span class="keyword">if</span> (partialImageRef) &#123;</span><br><span class="line">                <span class="keyword">const</span> size_t partialHeight = <span class="built_in">CGImageGetHeight</span>(partialImageRef);</span><br><span class="line">                <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">                <span class="built_in">CGContextRef</span> bmContext = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>, width, height, <span class="number">8</span>, width * <span class="number">4</span>, colorSpace, k<span class="built_in">CGBitmapByteOrderDefault</span> | k<span class="built_in">CGImageAlphaPremultipliedFirst</span>);</span><br><span class="line">                <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</span><br><span class="line">                <span class="keyword">if</span> (bmContext) &#123;</span><br><span class="line">                    <span class="built_in">CGContextDrawImage</span>(bmContext, (<span class="built_in">CGRect</span>)&#123;<span class="variable">.origin</span><span class="variable">.x</span> = <span class="number">0.0</span>f, <span class="variable">.origin</span><span class="variable">.y</span> = <span class="number">0.0</span>f, <span class="variable">.size</span><span class="variable">.width</span> = width, <span class="variable">.size</span><span class="variable">.height</span> = partialHeight&#125;, partialImageRef);</span><br><span class="line">                    <span class="built_in">CGImageRelease</span>(partialImageRef);</span><br><span class="line">                    partialImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(bmContext);</span><br><span class="line">                    <span class="built_in">CGContextRelease</span>(bmContext);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">CGImageRelease</span>(partialImageRef);</span><br><span class="line">                    partialImageRef = <span class="literal">nil</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (partialImageRef) &#123;</span><br><span class="line">                <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWith<span class="built_in">CGImage</span>:partialImageRef scale:<span class="number">1</span> orientation:orientation];</span><br><span class="line">                <span class="built_in">NSString</span> *key = [[SDWebImageManager sharedManager] cacheKeyForURL:<span class="keyword">self</span><span class="variable">.request</span><span class="variable">.URL</span>];</span><br><span class="line">                <span class="comment">// 对图片进行缩放</span></span><br><span class="line">                <span class="built_in">UIImage</span> *scaledImage = [<span class="keyword">self</span> scaledImageForKey:key image:image];</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.shouldDecompressImages</span>) &#123;</span><br><span class="line">                    <span class="comment">// 对图片解压缩</span></span><br><span class="line">                    image = [<span class="built_in">UIImage</span> decodedImageWithImage:scaledImage];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    image = scaledImage;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">CGImageRelease</span>(partialImageRef);</span><br><span class="line">                dispatch_main_sync_safe(^&#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.completedBlock</span>) &#123;</span><br><span class="line">                        <span class="keyword">self</span><span class="variable">.completedBlock</span>(image, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">NO</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">CFRelease</span>(imageSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.progressBlock</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.progressBlock</span>(<span class="keyword">self</span><span class="variable">.imageData</span><span class="variable">.length</span>, <span class="keyword">self</span><span class="variable">.expectedSize</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然<code>SDWebImageDownloaderOperation</code>本质是个NSOperation，有start方法启动，并在start方法里创建NSURLSession下载图片，更具体的可以看我注解的源码，这里不再赘述。</p>
<h3 id="Cache">Cache</h3><p>主要就一个类<code>SDImageCache</code>,这个类管理了对图片的缓存操作，包括内存缓存和磁盘缓存。<br>内存缓存是用NSCache实现的，以Key-Value的形式存储图片，当内存不够的时候会清除所有缓存图片。<br>磁盘缓存则是缓存到沙盒中，需要注意的文件名是key做MD5后的字符串，文件替换方式是以时间为单位，剔除时间大于一周的图片文件。<br>流程7中调用的主要代码为：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)storeImage:(<span class="built_in">UIImage</span> *)image recalculateFromImage:(<span class="built_in">BOOL</span>)recalculate imageData:(<span class="built_in">NSData</span> *)imageData forKey:(<span class="built_in">NSString</span> *)key toDisk:(<span class="built_in">BOOL</span>)toDisk &#123;</span><br><span class="line">    <span class="keyword">if</span> (!image || !key) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内存缓存 存入NSCache</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.shouldCacheImagesInMemory</span>) &#123;</span><br><span class="line">        <span class="comment">// 图片cost值</span></span><br><span class="line">        <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(image);</span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.memCache</span> setObject:image forKey:key cost:cost];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 磁盘缓存</span></span><br><span class="line">    <span class="keyword">if</span> (toDisk) &#123;</span><br><span class="line">        <span class="comment">// 磁盘缓存，则将缓存操作作为一个任务放入ioQueue(串行队列)中</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(<span class="keyword">self</span><span class="variable">.ioQueue</span>, ^&#123;</span><br><span class="line">            <span class="built_in">NSData</span> *data = imageData;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (image &amp;&amp; (recalculate || !data)) &#123;</span><br><span class="line"><span class="preprocessor">#if TARGET_OS_IPHONE</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 需要确定图片是PNG还是JPEG。PNG图片容易检测，因为有一个唯一签名。PNG图像的前8个字节总是包含以下值：137 80 78 71 13 10 26 10</span></span><br><span class="line">                <span class="comment">// 在imageData为nil的情况下假定图像为PNG。我们将其当作PNG以避免丢失透明度。而当有图片数据时，我们检测其前缀，确定图片的类型</span></span><br><span class="line">                <span class="keyword">int</span> alphaInfo = <span class="built_in">CGImageGetAlphaInfo</span>(image<span class="variable">.CGImage</span>);</span><br><span class="line">                <span class="built_in">BOOL</span> hasAlpha = !(alphaInfo == k<span class="built_in">CGImageAlphaNone</span> ||</span><br><span class="line">                                  alphaInfo == k<span class="built_in">CGImageAlphaNoneSkipFirst</span> ||</span><br><span class="line">                                  alphaInfo == k<span class="built_in">CGImageAlphaNoneSkipLast</span>);</span><br><span class="line">                <span class="built_in">BOOL</span> imageIsPng = hasAlpha;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 当有图片数据时，我们检测其前缀，确定图片的类型</span></span><br><span class="line">                <span class="keyword">if</span> ([imageData length] &gt;= [kPNGSignatureData length]) &#123;</span><br><span class="line">                    imageIsPng = ImageDataHasPNGPreffix(imageData);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (imageIsPng) &#123;</span><br><span class="line">                    data = <span class="built_in">UIImagePNGRepresentation</span>(image);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    data = <span class="built_in">UIImageJPEGRepresentation</span>(image, (<span class="built_in">CGFloat</span>)<span class="number">1.0</span>);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="preprocessor">#else</span></span><br><span class="line">                data = [<span class="built_in">NSBitmapImageRep</span> representationOfImageRepsInArray:image<span class="variable">.representations</span> usingType: <span class="built_in">NSJPEGFileType</span> properties:<span class="literal">nil</span>];</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 创建缓存文件并存储图片</span></span><br><span class="line">            [<span class="keyword">self</span> storeImageDataToDisk:data forKey:key];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>磁盘缓存的自动清理机制为：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)cleanDiskWithCompletionBlock:(SDWebImageNoParamsBlock)completionBlock &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span><span class="variable">.ioQueue</span>, ^&#123;</span><br><span class="line">        <span class="built_in">NSURL</span> *diskCacheURL = [<span class="built_in">NSURL</span> fileURLWithPath:<span class="keyword">self</span><span class="variable">.diskCachePath</span> isDirectory:<span class="literal">YES</span>];</span><br><span class="line">        <span class="built_in">NSArray</span> *resourceKeys = @[<span class="built_in">NSURLIsDirectoryKey</span>, <span class="built_in">NSURLContentModificationDateKey</span>, <span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该枚举器预先获取缓存文件的有用的属性</span></span><br><span class="line">        <span class="built_in">NSDirectoryEnumerator</span> *fileEnumerator = [_fileManager enumeratorAtURL:diskCacheURL</span><br><span class="line">                                                   includingPropertiesForKeys:resourceKeys</span><br><span class="line">                                                                      options:<span class="built_in">NSDirectoryEnumerationSkipsHiddenFiles</span></span><br><span class="line">                                                                 errorHandler:<span class="literal">NULL</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSDate</span> *expirationDate = [<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:-<span class="keyword">self</span><span class="variable">.maxCacheAge</span>];</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *cacheFiles = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">        <span class="built_in">NSUInteger</span> currentCacheSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举缓存文件夹中所有文件，该迭代有两个目的：移除比过期日期更老的文件；存储文件属性以备后面执行基于缓存大小的清理操作</span></span><br><span class="line">        <span class="built_in">NSMutableArray</span> *urlsToDelete = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> fileEnumerator) &#123;</span><br><span class="line">            <span class="built_in">NSDictionary</span> *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:<span class="literal">NULL</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Skip directories.</span></span><br><span class="line">            <span class="keyword">if</span> ([resourceValues[<span class="built_in">NSURLIsDirectoryKey</span>] boolValue]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移除旧的过期文件</span></span><br><span class="line">            <span class="built_in">NSDate</span> *modificationDate = resourceValues[<span class="built_in">NSURLContentModificationDateKey</span>];</span><br><span class="line">            <span class="keyword">if</span> ([[modificationDate laterDate:expirationDate] isEqualToDate:expirationDate]) &#123;</span><br><span class="line">                [urlsToDelete addObject:fileURL];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 存储文件的引用，计算文件的总大小</span></span><br><span class="line">            <span class="built_in">NSNumber</span> *totalAllocatedSize = resourceValues[<span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</span><br><span class="line">            currentCacheSize += [totalAllocatedSize unsignedIntegerValue];</span><br><span class="line">            [cacheFiles setObject:resourceValues forKey:fileURL];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> urlsToDelete) &#123;</span><br><span class="line">            [_fileManager removeItemAtURL:fileURL error:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果磁盘缓存的大小大于我们配置的最大大小，则执行基于文件大小的清理，我们首先删除最老的文件</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.maxCacheSize</span> &gt; <span class="number">0</span> &amp;&amp; currentCacheSize &gt; <span class="keyword">self</span><span class="variable">.maxCacheSize</span>) &#123;</span><br><span class="line">            <span class="comment">// 以设置的最大缓存大小的一半作为清理目标</span></span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">NSUInteger</span> desiredCacheSize = <span class="keyword">self</span><span class="variable">.maxCacheSize</span> / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 按照最后修改时间来排序剩下的缓存文件</span></span><br><span class="line">            <span class="built_in">NSArray</span> *sortedFiles = [cacheFiles keysSortedByValueWithOptions:<span class="built_in">NSSortConcurrent</span></span><br><span class="line">                                                            usingComparator:^<span class="built_in">NSComparisonResult</span>(<span class="keyword">id</span> obj1, <span class="keyword">id</span> obj2) &#123;</span><br><span class="line">                                                                <span class="keyword">return</span> [obj1[<span class="built_in">NSURLContentModificationDateKey</span>] compare:obj2[<span class="built_in">NSURLContentModificationDateKey</span>]];</span><br><span class="line">                                                            &#125;];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 删除文件，直到缓存总大小降到我们期望的大小</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> sortedFiles) &#123;</span><br><span class="line">                <span class="keyword">if</span> ([_fileManager removeItemAtURL:fileURL error:<span class="literal">nil</span>]) &#123;</span><br><span class="line">                    <span class="built_in">NSDictionary</span> *resourceValues = cacheFiles[fileURL];</span><br><span class="line">                    <span class="built_in">NSNumber</span> *totalAllocatedSize = resourceValues[<span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</span><br><span class="line">                    currentCacheSize -= [totalAllocatedSize unsignedIntegerValue];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (currentCacheSize &lt; desiredCacheSize) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (completionBlock) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completionBlock();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SDWebImageManager下载图片前会先搜索内存层面的数据，如果有直接返回，没有的话去访问磁盘，将图片从磁盘读取出来，然后做Decoder，再将图片对象放到内存做备份。<br>更为具体关于图片的查询、删除可以看我注解的源码，这里不再赘述。</p>
<h3 id="Categories">Categories</h3><p>这里主要看<code>UIImageView+WebCache</code>这个类，在流程2中核心方法为：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="built_in">NSURL</span> *)url placeholderImage:(<span class="built_in">UIImage</span> *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock &#123;</span><br><span class="line">    <span class="comment">// 取消上一次操作</span></span><br><span class="line">    [<span class="keyword">self</span> sd_cancelCurrentImageLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拿到url，在这里setAssociatedObject</span></span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;imageURLKey, url, OBJC_ASSO<span class="built_in">CIATION_RETAIN_NONATOMIC</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">        <span class="comment">// 确保在主线程中执行操作</span></span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            <span class="keyword">self</span><span class="variable">.image</span> = placeholder;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (url) &#123;</span><br><span class="line">        <span class="comment">// check if activityView is enabled or not</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> showActivityIndicatorView]) &#123;</span><br><span class="line">            [<span class="keyword">self</span> addActivityIndicator];</span><br><span class="line">        &#125;</span><br><span class="line">        __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)wself = <span class="keyword">self</span>;</span><br><span class="line">        <span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation = [SDWebImageManager<span class="variable">.sharedManager</span> downloadImageWithURL:url options:options progress:progressBlock completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) &#123;</span><br><span class="line">            [wself removeActivityIndicator];</span><br><span class="line">            <span class="keyword">if</span> (!wself) <span class="keyword">return</span>;</span><br><span class="line">            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                <span class="keyword">if</span> (!wself) <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">// 选择了SDWebImageAvoidAutoSetImage标记，会先返回image不加载图片，以便添加动画效果或过滤器</span></span><br><span class="line">                <span class="keyword">if</span> (image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock)</span><br><span class="line">                &#123;</span><br><span class="line">                    completedBlock(image, error, cacheType, url);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 只有image，下载成功后加载</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (image) &#123;</span><br><span class="line">                    wself<span class="variable">.image</span> = image;</span><br><span class="line">                    [wself setNeedsLayout];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 图片不存在或下载失败或SDWebImageDelayPlaceholder，加载placeholder</span></span><br><span class="line">                    <span class="keyword">if</span> ((options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">                        wself<span class="variable">.image</span> = placeholder;</span><br><span class="line">                        [wself setNeedsLayout];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (completedBlock &amp;&amp; finished) &#123;</span><br><span class="line">                    completedBlock(image, error, cacheType, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;];</span><br><span class="line">        <span class="comment">// 保存本次操作,保存前会先cancel上次操作</span></span><br><span class="line">        [<span class="keyword">self</span> sd_setImageLoadOperation:operation forKey:<span class="string">@"UIImageViewImageLoad"</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            [<span class="keyword">self</span> removeActivityIndicator];</span><br><span class="line">            <span class="keyword">if</span> (completedBlock) &#123;</span><br><span class="line">                <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:SDWebImageErrorDomain code:-<span class="number">1</span> userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@"Trying to load a nil url"</span>&#125;];</span><br><span class="line">                <span class="comment">// url不存在，SDImageCacheTypeNone</span></span><br><span class="line">                completedBlock(<span class="literal">nil</span>, error, SDImageCacheTypeNone, url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结">总结</h3><ul>
<li>1.主动为开发者考虑<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Very common mistake is to send the URL using NSString object instead of NSURL. For some strange reason, XCode won't</span></span><br><span class="line"><span class="comment">// throw any warning for this type mismatch. Here we failsafe this error by allowing URLs to be passed as NSString.</span></span><br><span class="line"><span class="keyword">if</span> ([url <span class="string">isKindOfClass:</span>NSString.<span class="keyword">class</span>]) &#123;</span><br><span class="line">    url = [NSURL <span class="string">URLWithString:</span>(NSString *)url];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>代码里在判断url的合法性上，主动帮将NSString当NSURL的新手擦屁股，连这个问题都考虑到了，是不是有很多在这里报错的人给他提issue呢？（笑~</p>
<ul>
<li><p>2.位移枚举<br>又回顾了一遍位移枚举。</p>
</li>
<li><p>3.dispatch_main_async_safe</p>
</li>
</ul>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define dispatch_main_async_safe(block)\</span></span><br><span class="line">    <span class="keyword">if</span> ([NSThread isMainThread]) &#123;<span class="string">\</span></span><br><span class="line">        block();<span class="string">\</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="string">\</span></span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), block);<span class="string">\</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>目的是想在主线程中执行操作，为什么要判断当前线程是否就是主线程中呢？<br>如果在主线程中执行dispatch_sync(dispatch_get_main_queue(), block) 同步操作时，会出现死锁问题，因为主线程正在执行当前代码，根本无法将block添加到主队列中。</p>
<ul>
<li><p>4.@synchronized<br>相当于加锁，在SDWebImage里表现为<code>@synchronized(syncObject) { }</code>,具体的说，是在某个对象实例内，可以防止多个线程同时访问这个对象的synchronized方法（如果一个对象有多个synchronized方法，只要一个线程访问了其中的一个synchronized方法，其它线程不能同时访问这个对象中任何一个synchronized方法）。这时，不同的对象实例的 synchronized方法是不相干扰的。也就是说，其它线程照样可以同时访问相同类的另一个对象实例中的synchronized方法；<br>这里引申一个，若同时重写某属性的setter和getter方法后，需加上<code>@synthesize propertyName = _propertyName;</code>，这是因为同时重写后，系统就不会帮你自动生成这个成员变量。</p>
</li>
<li><p>5.开启后台任务</p>
</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)backgroundCleanDisk &#123;</span><br><span class="line">    Class <span class="built_in">UIApplicationClass</span> = <span class="built_in">NSClassFromString</span>(<span class="string">@"UIApplication"</span>);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">UIApplicationClass</span> || ![<span class="built_in">UIApplicationClass</span> respondsToSelector:<span class="keyword">@selector</span>(sharedApplication)]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">UIApplication</span> *application = [<span class="built_in">UIApplication</span> performSelector:<span class="keyword">@selector</span>(sharedApplication)];</span><br><span class="line">    __block <span class="built_in">UIBackgroundTaskIdentifier</span> bgTask = [application beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">        <span class="comment">// 清理任何未完成的任务作业，标记完全停止或结束任务。</span></span><br><span class="line">        [application endBackgroundTask:bgTask];</span><br><span class="line">        bgTask = <span class="built_in">UIBackgroundTaskInvalid</span>;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始长时间后台运行的任务并且立即return。</span></span><br><span class="line">    [<span class="keyword">self</span> cleanDiskWithCompletionBlock:^&#123;</span><br><span class="line">        [application endBackgroundTask:bgTask];</span><br><span class="line">        bgTask = <span class="built_in">UIBackgroundTaskInvalid</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想要提高还得看源码，总的来说阅读源码获益匪浅。<br>相关的注解在<a href="https://github.com/v2panda/PDSourceNotes" target="_blank" rel="external">这里</a>。</p>
<h3 id="Reference">Reference</h3><p><a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">https://github.com/rs/SDWebImage</a><br><a href="http://blog.csdn.net/uxyheaven/article/details/7909373" target="_blank" rel="external">http://blog.csdn.net/uxyheaven/article/details/7909373</a><br><a href="http://southpeak.github.io/blog/2015/02/07/sourcecode-sdwebimage/" target="_blank" rel="external">http://southpeak.github.io/blog/2015/02/07/sourcecode-sdwebimage/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/rs/SDWebImage&quot;&gt;SDWebImage&lt;/a&gt;是一个图片加载库，目前在Github上已有将近14k的star了，这篇文章记录了阅读SDWebImage源码的笔记(Version 3.8)，简单的研究了它的实现细节。&lt;/p&gt;
&lt;h3 id=&quot;流程&quot;&gt;流程&lt;/h3&gt;&lt;p&gt;SDWebImage加载图片的大致流程，以UIImageView+WebCache为例。&lt;/p&gt;
&lt;p&gt;1.调用基础入口方法&lt;br&gt;&lt;code&gt;sd_setImageWithURL:&lt;/code&gt;,&lt;code&gt;sd_setImageWithURL:placeholderImage:&lt;/code&gt;,&lt;code&gt;sd_setImageWithURL:placeholderImage:options:&lt;/code&gt;等等&lt;/p&gt;
&lt;p&gt;2.进入&lt;code&gt;sd_setImageWithURL:placeholderImage:options:progress:completed:&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;3.进入&lt;code&gt;downloadImageWithURL:options:progress:completed:&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;4.调用SDWebImageDownloader下载图片&lt;code&gt;downloadImageWithURL:options:progress:completed:&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;5.调用&lt;code&gt;addProgressCallback:completedBlock:forURL:createCallback:&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;6.初始化SDWebImageDownloaderOperation&lt;br&gt;&lt;code&gt;initWithRequest:inSession:options:progress:completed:cancelled:&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;7.缓存图片调用&lt;code&gt;storeImage:recalculateFromImage:imageData:forKey:toDisk:&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;以上方法是调用链上的主要方法，将在下文逐一解释。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SimpleNote 2.0 - 用心记录文字</title>
    <link href="http://v2panda.com/2016/05/28/simplenote/"/>
    <id>http://v2panda.com/2016/05/28/simplenote/</id>
    <published>2016-05-28T10:30:57.000Z</published>
    <updated>2016-05-28T10:32:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>SimpleNote是一个记录你自己的笔记应用，温暖、简约，用心记录文字，感受书写的本质。</p>
<p>地址：<a href="https://github.com/v2panda/SimpleNote" target="_blank" rel="external">https://github.com/v2panda/SimpleNote</a></p>
<p>SimpleNote是大四实习时写的一个App，但现在看看以前的代码，各种问题、漏洞百出，无法忍受。就决定重构出2.0版本，于是在业余时间里断断续续做这个App，算是重构了一遍吧，这次也放弃写UI的方式，使用StoryBoard+xib的方式布局。</p>
<a id="more"></a>
<h3 id="为什么要重构？">为什么要重构？</h3><ul>
<li>觉得以前写的代码太烂</li>
<li>充实业余时间，要是一段时间我什么东西都没折腾出来，我会感到很不安</li>
<li>重构可以帮我整理自己的思路，优化以前的烂代码</li>
<li>找回按自己意愿编程的感觉(这跟工作上的编程是完全不同的)</li>
</ul>
<h3 id="结果反思">结果反思</h3><p>目前做App对我来说最大的困难就是设计了，这里不光是UI上的设计，还有产品上的，这都是我的短板。前期在设计上花了挺多时间，中间也有各种新的想法，新的功能添加，这导致我在写代码时走了不少弯路，很多页面和功能实现出来后觉得不好看或者不满意，又都删掉了。在这删删改改的过程中，感受到了一个好产品经理的重要性。更体会到从有个好Idea，到真正去实现这个Idea中间还有好多路要走。</p>
<h3 id="感谢开源">感谢开源</h3><ul>
<li>本地存储：<a href="https://realm.io/" target="_blank" rel="external">Realm</a></li>
<li>后台：<a href="https://leancloud.cn/" target="_blank" rel="external">LeanCloud</a></li>
<li>图文混排：<a href="https://github.com/ibireme/YYText" target="_blank" rel="external">YYText</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SimpleNote是一个记录你自己的笔记应用，温暖、简约，用心记录文字，感受书写的本质。&lt;/p&gt;
&lt;p&gt;地址：&lt;a href=&quot;https://github.com/v2panda/SimpleNote&quot;&gt;https://github.com/v2panda/SimpleNote&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SimpleNote是大四实习时写的一个App，但现在看看以前的代码，各种问题、漏洞百出，无法忍受。就决定重构出2.0版本，于是在业余时间里断断续续做这个App，算是重构了一遍吧，这次也放弃写UI的方式，使用StoryBoard+xib的方式布局。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>APP砸壳</title>
    <link href="http://v2panda.com/2016/04/24/app-reverse/"/>
    <id>http://v2panda.com/2016/04/24/app-reverse/</id>
    <published>2016-04-24T06:06:55.000Z</published>
    <updated>2016-04-24T06:11:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="工具">工具</h3><ul>
<li><a href="http://stevenygard.com/projects/*class-dump*/" target="_blank" rel="external">class-dump</a></li>
<li><a href="https://github.com/stefanesser/dumpdecrypted" target="_blank" rel="external">dumpdecrypted</a></li>
<li>一部越狱手机</li>
<li>OpenSSH(Cydia)</li>
<li>Cycript(Cydia)</li>
<li>adv-cmds(Cydia)</li>
</ul>
<a id="more"></a>
<h3 id="步骤">步骤</h3><p>1.用ssh进入连上的iPhone<strong>(确保iPhone和Mac在同一个网段)</strong>。OpenSSH的root密码默认为<em>alpine</em>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@<span class="number">192.168</span><span class="number">.2</span><span class="number">.10</span></span><br></pre></td></tr></table></figure>
<p>2.关闭所有后台app，仅保持需要破解的app在后台，输入命令<code>ps -e</code>，找到app的bundle地址,如6429行所示</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6408</span> ??         <span class="number">0</span>:<span class="number">00.40</span> /usr/libexec/ptpd -t usb</span><br><span class="line"><span class="number">6429</span> ??         <span class="number">0</span>:<span class="number">01.44</span> /var/mobile/Containers/Bundle/Application/<span class="number">79909146</span>-D31F-<span class="number">4225</span>-B18E-<span class="number">8</span>D08D5599FFA/XXX.app/XXX</span><br><span class="line"><span class="number">6448</span> ??         <span class="number">0</span>:<span class="number">00.28</span> sshd: root@ttys000</span><br><span class="line"><span class="number">6450</span> ttys000    <span class="number">0</span>:<span class="number">00.05</span> -sh</span><br><span class="line"><span class="number">6487</span> ttys000    <span class="number">0</span>:<span class="number">00.01</span> ps -e</span><br></pre></td></tr></table></figure>
<p>3.使用cycript命令，找到目标app的Documents路径，输入<code>cycript -p XXX</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v2panda-iPhone-<span class="number">5</span>s:~ root<span class="preprocessor"># cycript -p XXX</span></span><br><span class="line">cy<span class="preprocessor">#</span></span><br></pre></td></tr></table></figure>
<p>在cy#后键入</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="link_label">[NSFileManager defaultManager</span>] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask][0]</span><br></pre></td></tr></table></figure>
<p>如图，记录下Documents地址，ctrl+z退出</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v2panda-iPhone-5s:~ root# cycript -p XXX</span><br><span class="line">cy# [<span class="link_label">[NSFileManager defaultManager</span>] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask][0]</span><br><span class="line"><span class="header">#"file:///var/mobile/Containers/Data/Application/9491960B-BAE6-439A-B210-3B183AB657EF/Documents/"</span></span><br><span class="line">cy#</span><br></pre></td></tr></table></figure>
<p>4.将生成的将dumpdecrypted.dylib拷贝到Documents目录下</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scp dumpdecrypted.dylib root<span class="variable">@192</span>.<span class="number">168.2</span>.<span class="number">10</span><span class="symbol">:/var/mobile/Containers/Data/Application/</span><span class="number">9491960</span>B-<span class="constant">BAE6</span>-<span class="number">439</span>A-<span class="constant">B210</span>-<span class="number">3</span>B183AB657EF/<span class="constant">Documents</span>/</span><br><span class="line">root<span class="variable">@192</span>.<span class="number">168.2</span>.<span class="number">10</span><span class="string">'s password:</span><br><span class="line">dumpdecrypted.dylib                                                                                          100%  193KB 192.9KB/s   00:00</span></span><br></pre></td></tr></table></figure>
<p>5.开始砸壳，使用以下命令，会在当前目录下生成XXX.decrypted砸壳后的文件。</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">DYLD_INSERT_LIBRARIES</span>=<span class="regexp">/path/to</span><span class="regexp">/dumpdecrypted.dylib /path</span><span class="regexp">/to/executable</span></span><br></pre></td></tr></table></figure>
<p>具体的为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">v2panda-iPhone-<span class="number">5</span>s:~ root<span class="preprocessor"># DYLD_INSERT_LIBRARIES=/var/mobile/Containers/Data/Application/<span class="number">9491960</span>B-BAE6-<span class="number">439</span>A-B210-<span class="number">3</span>B183AB657EF/Documents/dumpdecrypted.dylib /var/mobile/Containers/Bundle/Application/<span class="number">79909146</span>-D31F-<span class="number">4225</span>-B18E-<span class="number">8</span>D08D5599FFA/XXX.app/XXX</span></span><br><span class="line">mach-o decryption dumper</span><br><span class="line"></span><br><span class="line">DISCLAIMER: This tool is only meant <span class="keyword">for</span> security research purposes, not <span class="keyword">for</span> application crackers.</span><br><span class="line"></span><br><span class="line">[+] detected <span class="number">64</span>bit ARM binary in memory.</span><br><span class="line">[+] offset to cryptid found: @<span class="number">0x10003cb68</span>(from <span class="number">0x10003c000</span>) = b68</span><br><span class="line">[+] Found encrypted data at address <span class="number">00004000</span> of length <span class="number">180224</span> bytes - type <span class="number">1.</span></span><br><span class="line">[+] Opening /<span class="keyword">private</span>/var/mobile/Containers/Bundle/Application/<span class="number">79909146</span>-D31F-<span class="number">4225</span>-B18E-<span class="number">8</span>D08D5599FFA/XXX.app/XXX <span class="keyword">for</span> reading.</span><br><span class="line">[+] Reading header</span><br><span class="line">[+] Detecting header type</span><br><span class="line">[+] Executable is a FAT image - searching <span class="keyword">for</span> right architecture</span><br><span class="line">[+] Correct arch is at offset <span class="number">245760</span> in the file</span><br><span class="line">[+] Opening SimpleNote.decrypted <span class="keyword">for</span> writing.</span><br><span class="line">[+] Copying the not encrypted start of the file</span><br><span class="line">[+] Dumping the decrypted data into the file</span><br><span class="line">[+] Copying the not encrypted remainder of the file</span><br><span class="line">[+] Setting the LC_ENCRYPTION_INFO-&gt;cryptid to <span class="number">0</span> at offset <span class="number">3</span>cb68</span><br><span class="line">[+] Closing original file</span><br><span class="line">[+] Closing dump file</span><br><span class="line">v2panda-iPhone-<span class="number">5</span>s:~ root<span class="preprocessor">#</span></span><br></pre></td></tr></table></figure>
<p>6.将砸壳后的XXX.decrypted文件拷贝到电脑上。</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scp root<span class="variable">@192</span>.<span class="number">168.2</span>.<span class="number">10</span><span class="symbol">:/var/root/XXX</span>.decrypted /<span class="constant">Users</span>/v2panda/<span class="constant">Apps</span></span><br><span class="line">root<span class="variable">@192</span>.<span class="number">168.2</span>.<span class="number">10</span><span class="string">'s password:</span><br><span class="line">XXX.decrypted                                                                                         100%  507KB 253.7KB/s   00:02</span></span><br></pre></td></tr></table></figure>
<p>7.classdump之</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./<span class="class"><span class="keyword">class</span>-<span class="title">dump</span> -<span class="title">s</span> -<span class="title">S</span> -<span class="title">H</span> ./<span class="title">XXX</span>.<span class="title">decrypted</span> -<span class="title">o</span> ./<span class="title">sn</span></span></span><br></pre></td></tr></table></figure>
<p>这里以微信为例，7000+的文件。</p>
<p><img src="http://7xnmlk.com1.z0.glb.clouddn.com/app-reverse.jpeg" alt="WeChat.png"></p>
<h3 id="后记">后记</h3><p>这里简单记录下App砸壳的有关步骤,更多详细内容以及后续开发可到<a href="http://bbs.iosre.com/" target="_blank" rel="external">iOSRE</a>查看。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;工具&quot;&gt;工具&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stevenygard.com/projects/*class-dump*/&quot;&gt;class-dump&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/stefanesser/dumpdecrypted&quot;&gt;dumpdecrypted&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;一部越狱手机&lt;/li&gt;
&lt;li&gt;OpenSSH(Cydia)&lt;/li&gt;
&lt;li&gt;Cycript(Cydia)&lt;/li&gt;
&lt;li&gt;adv-cmds(Cydia)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基于JSPatch的在线更新</title>
    <link href="http://v2panda.com/2016/03/29/hotfix-jspatch/"/>
    <id>http://v2panda.com/2016/03/29/hotfix-jspatch/</id>
    <published>2016-03-29T12:21:33.000Z</published>
    <updated>2016-03-29T12:32:59.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>限于AppStore的审核机制，苹果应用审核通常需要一段时间。这对某些应用开发迭代比较快的公司来说，往往上一版本还在AppStore审核，新一版本已经开发完毕了，相对于Android的当天发布来说，已经算是不能再慢了。要是正好遇上线上有bug，那么又得重新回到AppStore提交-审核-发布的流程中去，但若是十分紧要的bug，不修复会影响应用的正常使用，那么再走这个流程就显得非常慢了。以前面对这种问题往往是走加急审核，但加急审核也会有3天时间，那能不能不发布版本在线上修复bug呢？答案是有的，这里选择的方案是JSPatch。</p>
<a id="more"></a>
<h3 id="JSPatch简介">JSPatch简介</h3><p>JSPatch是由国人开发的开源项目(<a href="https://github.com/bang590/JSPatch" target="_blank" rel="external">Github链接</a>)只需要在项目里引入极小的引擎文件，就可以使用 JavaScript 调用任何 Objective-C 的原生接口，替换任意 Objective-C 原生方法。目前主要用于下发 JS 脚本替换原生 Objective-C 代码，实时修复线上 bug。<br>关于JSPatch的实现原理可以参考<a href="http://blog.cnbang.net/archives/" target="_blank" rel="external">作者的博客</a>。</p>
<h3 id="语法">语法</h3><p>JSPatch使用简单明了，但需要注意的是JSPatch的语法，将OC语言转为JSPatch，例如：</p>
<ul>
<li>OC</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@implementation</span> SampleClass</span><br><span class="line">- (<span class="typename">void</span>)<span class="string">requestUrl:</span>(NSString *)url <span class="string">param:</span>(NSDictionary *)dict <span class="string">callback:</span>(JPCallback)callback &#123;</span><br><span class="line">    [<span class="keyword">super</span> <span class="string">requestUrl:</span>url <span class="string">param:</span>dict <span class="string">callback:</span>callback];</span><br><span class="line">    JPRequest *obj = [[JPRequest alloc] <span class="string">initWithUrl:</span>url <span class="string">param:</span>dict];</span><br><span class="line">    obj.successBlock = ^(id data, NSError *err) &#123;</span><br><span class="line">        NSString *content = [JPParser <span class="string">parseData:</span>data];</span><br><span class="line">        <span class="keyword">if</span> (callback) callback(@&#123;</span><br><span class="line">            @<span class="string">"content"</span>: content</span><br><span class="line">        &#125;, err);</span><br><span class="line">        [self.dataSource refresh];</span><br><span class="line">        self.handleRequestSuccess(data);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="annotation">@end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>JSPatch</li>
</ul>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">require<span class="list">(<span class="quoted">'JPRequest</span>,JPParser')</span><span class="comment">;</span></span><br><span class="line">defineClass<span class="list">(<span class="quoted">'SampleClass</span>', &#123;</span><br><span class="line">    requestUrl_param_callback: function<span class="list">(<span class="keyword">url</span>, dict, callback)</span> &#123;</span><br><span class="line">        self.super<span class="list">()</span>.requestUrl_param_callback<span class="list">(<span class="keyword">url</span>, dict, callback)</span><span class="comment">;</span></span><br><span class="line">        var obj = JPRequest.alloc<span class="list">()</span>.initWithUrl_param<span class="list">(<span class="keyword">url</span>, dict)</span><span class="comment">;</span></span><br><span class="line">        obj.setSuccessBlock<span class="list">(<span class="keyword">block</span><span class="list">(<span class="quoted">'id</span>,NSError*', function<span class="list">(<span class="keyword">data</span>, err)</span> &#123;</span><br><span class="line">            var content = JPParser.parseData<span class="list">(<span class="keyword">data</span>)</span><span class="comment">;</span></span><br><span class="line">            if <span class="list">(<span class="keyword">callback</span>)</span> callback<span class="list">(&#123;</span><br><span class="line">                <span class="string">"content"</span>: content</span><br><span class="line">            &#125;, err)</span><span class="comment">;</span></span><br><span class="line">            self.dataSource<span class="list">()</span>.refresh<span class="list">()</span><span class="comment">;</span></span><br><span class="line">            self.handleRequestSuccess<span class="list">()</span><span class="list">(<span class="keyword">data</span>)</span><span class="comment">;</span></span><br><span class="line">        &#125;)</span>)</span><span class="comment">;</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>作者提供了一个<a href="http://bang590.github.io/JSPatchConvertor/" target="_blank" rel="external">JSPatchConvertor</a>简单粗暴，能满足一些简单的转换，比较复杂的就得人工修改了，更多语法上的可以参考<a href="https://github.com/bang590/JSPatch/wiki/JSPatch-%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95" target="_blank" rel="external">JSPatchWiki</a>。</p>
<h3 id="安全">安全</h3><p>使用 JSPatch 有两个安全问题：</p>
<ul>
<li>传输安全：JS 脚本可以调用任意 OC 方法，权限非常大，若被中间人攻击替换代码，会造成较大的危害。</li>
<li>执行安全：下发的 JS 脚本灵活度大，相当于一次小型更新，若未进行充分测试，可能会出现 crash 等情况对 APP 稳定性造成影响。</li>
</ul>
<p>作者推荐的一种方案如图所示:<br><img src="http://7xnmlk.com1.z0.glb.clouddn.com/JSPatchSecurity.png" alt="JSPatchSecurity"><br>1.服务端计算出脚本文件的 MD5 值，作为这个文件的数字签名。<br>2.服务端通过私钥加密第 1 步算出的 MD5 值，得到一个加密后的 MD5 值。<br>3.把脚本文件和加密后的 MD5 值一起下发给客户端。<br>4.客户端拿到加密后的 MD5 值，通过保存在客户端的公钥解密。<br>5.客户端计算脚本文件的 MD5 值。<br>6.对比第 4/5 步的两个 MD5 值（分别是客户端和服务端计算出来的 MD5 值），若相等则通过校验。<br>对于JSPatch若有更多安全上的顾虑可以参考作者的<a href="http://blog.cnbang.net/internet/2990/" target="_blank" rel="external">回应一下 JSPatch 安全问题</a>。</p>
<h3 id="使用">使用</h3><p>目前有两种使用方法，一种是使用作者提供的<a href="http://jspatch.com/" target="_blank" rel="external">JSPatch Platform</a>平台，集成JSPatch的SDK，按请求次数收费，目前免费额度为 100w次请求/月，超出的部分会另行收费。<br>还有一种是自己造轮子，毕竟JSPatch是开源的，从前端逻辑到后台安全策略，都可以根据公司的业务需求自由定制。</p>
<h3 id="后记">后记</h3><p>总体来说还是十分好用的，需要注意的是每次版本用JSPatch解决的线上Bug后，下个版本必须得将代码写入项目中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;&lt;p&gt;限于AppStore的审核机制，苹果应用审核通常需要一段时间。这对某些应用开发迭代比较快的公司来说，往往上一版本还在AppStore审核，新一版本已经开发完毕了，相对于Android的当天发布来说，已经算是不能再慢了。要是正好遇上线上有bug，那么又得重新回到AppStore提交-审核-发布的流程中去，但若是十分紧要的bug，不修复会影响应用的正常使用，那么再走这个流程就显得非常慢了。以前面对这种问题往往是走加急审核，但加急审核也会有3天时间，那能不能不发布版本在线上修复bug呢？答案是有的，这里选择的方案是JSPatch。&lt;/p&gt;
    
    </summary>
    
    
      <category term="hotfix" scheme="http://v2panda.com/tags/hotfix/"/>
    
  </entry>
  
  <entry>
    <title>iOS搭建CI持续集成环境</title>
    <link href="http://v2panda.com/2016/02/29/buildci/"/>
    <id>http://v2panda.com/2016/02/29/buildci/</id>
    <published>2016-02-29T15:49:05.000Z</published>
    <updated>2016-02-29T16:51:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言_Continuous_integration">前言 Continuous integration</h3><p>CI 是敏捷开发的必备，简单说就是有这样一套工具，使得开发人员做好开发和单元测试再 push 代码后就不用管了，这套工具能自动地 check 代码的变化，自动 build， 自动做集成测试和场景测试等，自动部署到生产环境。</p>
<p>本文为iOS下的自动化打包，搭建可持续集成环境，省去给测试安装新版本的时间，提高工作效率。这里选择的方案是Jenkins+ Gitlab/Github+Xcode+Fir。</p>
<a id="more"></a>
<h3 id="安装Jenkins">安装Jenkins</h3><p>先安装homebrew，安装过的跳过这步</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ruby <span class="operator">-e</span> <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></span><br></pre></td></tr></table></figure>
<p>然后</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">brew </span>install jenkins</span><br></pre></td></tr></table></figure>
<p>若遇到</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jenkins: Java 1.6+ is required to <span class="operator"><span class="keyword">install</span> this formula.</span><br><span class="line">You can <span class="keyword">install</span> <span class="keyword">with</span> Homebrew Cask:</span><br><span class="line">  brew <span class="keyword">install</span> Caskroom/cask/<span class="keyword">java</span></span><br><span class="line"></span><br><span class="line">You can download <span class="keyword">from</span>:</span><br><span class="line">  <span class="keyword">http</span>://www.<span class="keyword">oracle</span>.com/technetwork/<span class="keyword">java</span>/javase/downloads/<span class="keyword">index</span>.html</span><br><span class="line"><span class="keyword">Error</span>: An unsatisfied requirement <span class="keyword">failed</span> this <span class="keyword">build</span>.</span></span><br></pre></td></tr></table></figure>
<p>按照提示安装java环境，推荐去<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="external">java官网</a>下载。</p>
<p>安装完成后浏览器会自动打开Jenkins页面(<a href="http://localhost:8080" target="_blank" rel="external">http://localhost:8080</a>)<br>或输入</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>open /<span class="constant">Applications</span>/<span class="constant">Jenkins</span>/jenkins.war</span><br></pre></td></tr></table></figure>
<p>若端口有冲突，则修改端口</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ defaults <span class="keyword">write</span> /<span class="keyword">Library</span>/Preferences/org.jenkins-ci httpPort yourport</span><br></pre></td></tr></table></figure>
<p>再安装插件，在到jenkins页面，插件管理中安装以下插件</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GIT <span class="keyword">plugin</span></span><br><span class="line">GitHub <span class="keyword">plugin</span></span><br><span class="line">Gitlab <span class="keyword">plugin</span></span><br><span class="line"><span class="keyword">Post</span>-Build Script Plug-<span class="keyword">in</span></span><br><span class="line">Xcode integration</span><br></pre></td></tr></table></figure>
<p>安装fir-cli,详细的参考<a href="https://github.com/FIRHQ/fir-cli/blob/master/README.md" target="_blank" rel="external">文档</a></p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gem install fir-<span class="keyword">cli</span></span><br></pre></td></tr></table></figure>
<h3 id="新建项目">新建项目</h3><p>新建一个项目，选择自由风格的软件项目。</p>
<p><img src="http://7xnmlk.com1.z0.glb.clouddn.com/blognewItem.png" alt="newItem"><br>继续填写基本信息与源码管理,若选用Git则需注意填写Repositories地址与    Branches to build<br><img src="http://7xnmlk.com1.z0.glb.clouddn.com/blogbasicInfo.png" alt="basicInfo"></p>
<h3 id="构建配置">构建配置</h3><p>添加构建触发器,这里就是告诉Jenkins什么时候自动构建。<br><img src="http://7xnmlk.com1.z0.glb.clouddn.com/blogbuildWhen.png" alt="buildWhen"><br>这里选择的是有push到github时构建，也可以选Poll SCM设置构建时间<br><img src="http://7xnmlk.com1.z0.glb.clouddn.com/blogbuildPoll.png" alt="buildPoll"><br>这里的配置为周一到周五每天8点到9点之间执行一次。</p>
<p><img src="http://7xnmlk.com1.z0.glb.clouddn.com/blogexecuteShell.png" alt="executeShell"><br>选择构建配置为Execute Shell，填入</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fir</span> build_ipa <span class="variable">$&#123;WORKSPACE1&#125;</span> -o <span class="variable">$&#123;WORKSPACE2&#125;</span>/TestJenkins.ipa -p -T <span class="comment">#API Token#</span></span><br></pre></td></tr></table></figure>
<ul>
<li>WORKSPACE1——–为项目路径</li>
<li>WORKSPACE2——–ipa输出路径</li>
<li>#API Token#————fir API Token</li>
</ul>
<p>然后保存退出。</p>
<h3 id="构建">构建</h3><p>建议逐步构建，避免错误，构建历史如下<br><img src="http://7xnmlk.com1.z0.glb.clouddn.com/blogbuildHistory.png" alt=""></p>
<p>蓝色的为构建成功，红色为失败，若遇到以下类似的错误</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">PluginLoading</span>: <span class="string">Required plug-in compatibility UUID F41BD31E-2683-44B8-</span></span><br><span class="line"></span><br><span class="line"><span class="dos">AE7F-<span class="number">5</span>F09E919790E <span class="flow">for</span> plug-<span class="flow">in</span> <span class="built_in">at</span> <span class="built_in">path</span> '~/Library/Application Support/</span><br><span class="line"></span><br><span class="line">Developer/Shared/Xcode/Plug-ins/KSImageNamed.xcplugin' <span class="flow">not</span> present <span class="flow">in</span> </span><br><span class="line"></span><br><span class="line">DVTPlugInCompatibilityUUIDs</span></span><br></pre></td></tr></table></figure>
<p>可以参考<a href="http://stackoverflow.com/questions/20732327/xcode-5-required-plug-in-not-present-in-dvtplugincompatibilityuuids" target="_blank" rel="external">stackoverflow</a>。</p>
<h3 id="发布">发布</h3><p>构建成功后就可以在fir上看到应用了，扫码或打开短链接下载应用。<br><img src="http://7xnmlk.com1.z0.glb.clouddn.com/blogfirim.png" alt="firim"></p>
<p>注意这里只能安装开发者账号设备列表里的设备，个人开发者账号和企业账号有所区别</p>
<p><img src="http://7xnmlk.com1.z0.glb.clouddn.com/blogdeviceslist.png" alt="deviceslist"></p>
<p>详情可以查看<a href="http://fir.im/support/articles/faq/ios_certificate" target="_blank" rel="external">fir support</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言_Continuous_integration&quot;&gt;前言 Continuous integration&lt;/h3&gt;&lt;p&gt;CI 是敏捷开发的必备，简单说就是有这样一套工具，使得开发人员做好开发和单元测试再 push 代码后就不用管了，这套工具能自动地 check 代码的变化，自动 build， 自动做集成测试和场景测试等，自动部署到生产环境。&lt;/p&gt;
&lt;p&gt;本文为iOS下的自动化打包，搭建可持续集成环境，省去给测试安装新版本的时间，提高工作效率。这里选择的方案是Jenkins+ Gitlab/Github+Xcode+Fir。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PDPullToRefresh</title>
    <link href="http://v2panda.com/2016/01/17/PDPullToRefresh/"/>
    <id>http://v2panda.com/2016/01/17/PDPullToRefresh/</id>
    <published>2016-01-17T09:03:45.000Z</published>
    <updated>2016-01-18T12:34:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>周末仿写了半糖的下拉刷新，学了两句法语</p>
<ul>
<li>C’est La Vie    </li>
<li>La Vie est belle</li>
</ul>
<p>C’est La Vie 通常是用在较为消极的事情发生时，用于自我安慰或自我解嘲，鼓励自己或他人即使遇到了再大的难处，也要坦然笑对生活。鸡汤一下，开始正文。</p>
<p><img src="http://7xnmlk.com1.z0.glb.clouddn.com/2015-cheers.jpg" alt=""></p>
<a id="more"></a>
<h1 id="示例">示例</h1><ul>
<li>半糖</li>
</ul>
<p><img src="http://7xnmlk.com1.z0.glb.clouddn.com/PDPullToRefresh-bantang.gif" alt="半糖"></p>
<ul>
<li>PDPullToRefresh</li>
</ul>
<p><img src="http://7xnmlk.com1.z0.glb.clouddn.com/PDPullToRefresh.gif" alt="PDPullToRefresh"></p>
<h1 id="思路">思路</h1><p>PDPullToRefresh是给UIScrollView加的分类，包括PDHeaderRefreshView和PDFooterRefreshView ,整个刷新过程可分为两部分</p>
<ul>
<li>下拉时 - C’est La Vie 动画</li>
<li>刷新时 - La Vie est belle 动画</li>
</ul>
<h3 id="C’est_La_Vie_动画">C’est La Vie 动画</h3><p>首先得拿到C’est La Vie的字形，这里用到了CoreText，拿到字形后添加到layer.path上显示</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGMutablePathRef</span> letters = <span class="built_in">CGPathCreateMutable</span>();</span><br><span class="line">    </span><br><span class="line">    CTFontRef font = CTFontCreateWithName(<span class="built_in">CFSTR</span>(<span class="string">"HelveticaNeue-UltraLight"</span>), pFontSize, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">NSDictionary</span> *attrs = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:</span><br><span class="line">                           (__bridge <span class="keyword">id</span>)font, kCTFontAttributeName,</span><br><span class="line">                           <span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSAttributedString</span> *attrString = [[<span class="built_in">NSAttributedString</span> alloc] initWithString:animationString</span><br><span class="line">                                                                     attributes:attrs];</span><br><span class="line">    CTLineRef line = CTLineCreateWithAttributedString((<span class="built_in">CFAttributedStringRef</span>)attrString);</span><br><span class="line">    <span class="built_in">CFArrayRef</span> runArray = CTLineGetGlyphRuns(line);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// for each RUN</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">CFIndex</span> runIndex = <span class="number">0</span>; runIndex &lt; <span class="built_in">CFArrayGetCount</span>(runArray); runIndex++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Get FONT for this run</span></span><br><span class="line">        CTRunRef run = (CTRunRef)<span class="built_in">CFArrayGetValueAtIndex</span>(runArray, runIndex);</span><br><span class="line">        CTFontRef runFont = <span class="built_in">CFDictionaryGetValue</span>(CTRunGetAttributes(run), kCTFontAttributeName);</span><br><span class="line">        <span class="comment">// for each GLYPH in run</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">CFIndex</span> runGlyphIndex = <span class="number">0</span>; runGlyphIndex &lt; CTRunGetGlyphCount(run); runGlyphIndex++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// get Glyph &amp; Glyph-data</span></span><br><span class="line">            <span class="built_in">CFRange</span> thisGlyphRange = <span class="built_in">CFRangeMake</span>(runGlyphIndex, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">CGGlyph</span> glyph;</span><br><span class="line">            <span class="built_in">CGPoint</span> position;</span><br><span class="line">            CTRunGetGlyphs(run, thisGlyphRange, &amp;glyph);</span><br><span class="line">            CTRunGetPositions(run, thisGlyphRange, &amp;position);</span><br><span class="line">            <span class="comment">// Get PATH of outline</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">CGPathRef</span> letter = CTFontCreatePathForGlyph(runFont, glyph, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="built_in">CGAffineTransform</span> t = <span class="built_in">CGAffineTransformMakeTranslation</span>(position<span class="variable">.x</span>, position<span class="variable">.y</span>);</span><br><span class="line">                <span class="built_in">CGPathAddPath</span>(letters, &amp;t, letter);</span><br><span class="line">                <span class="built_in">CGPathRelease</span>(letter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CFRelease</span>(line);</span><br><span class="line">    <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line">    [path moveToPoint:<span class="built_in">CGPointZero</span>];</span><br><span class="line">    [path appendPath:[<span class="built_in">UIBezierPath</span> bezierPathWith<span class="built_in">CGPath</span>:letters]];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGPathRelease</span>(letters);</span><br><span class="line">    <span class="built_in">CFRelease</span>(font);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CAShapeLayer</span> *pathLayer = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">    pathLayer<span class="variable">.frame</span> = <span class="keyword">self</span><span class="variable">.animationLayer</span><span class="variable">.bounds</span>;</span><br><span class="line">    pathLayer<span class="variable">.bounds</span> = <span class="built_in">CGPathGetBoundingBox</span>(path<span class="variable">.CGPath</span>);</span><br><span class="line">    pathLayer<span class="variable">.geometryFlipped</span> = <span class="literal">YES</span>;</span><br><span class="line">    pathLayer<span class="variable">.path</span> = path<span class="variable">.CGPath</span>;</span><br><span class="line">    pathLayer<span class="variable">.strokeColor</span> = [<span class="built_in">UIColor</span> colorWithRed:<span class="number">234.0</span>/<span class="number">255</span> green:<span class="number">84.0</span>/<span class="number">255</span> blue:<span class="number">87.0</span>/<span class="number">255</span> alpha:<span class="number">1</span>]<span class="variable">.CGColor</span>;</span><br><span class="line">    pathLayer<span class="variable">.fillColor</span> = <span class="literal">nil</span>;</span><br><span class="line">    pathLayer<span class="variable">.lineWidth</span> = <span class="number">1.0</span>f;</span><br><span class="line">    pathLayer<span class="variable">.lineJoin</span> = k<span class="built_in">CALineJoinBevel</span>;</span><br></pre></td></tr></table></figure>
<p>然后用KVO监听ScrollView的contentOffset属性，与pathLayer的strokeEnd关联起来，C’est La Vie就可以随着下拉做动画啦。</p>
<h3 id="La_Vie_est_belle_动画">La Vie est belle 动画</h3><p>La Vie est belle与C’est La Vie的动画不同，它是一直闪动着的，还是先拿到La Vie est belle的字形，这里用CAGradientLayer可以方便的处理颜色渐变。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CAGradientLayer</span> *gradientLayer = (<span class="built_in">CAGradientLayer</span> *)<span class="keyword">self</span><span class="variable">.gradientLayer</span>;</span><br><span class="line">    <span class="keyword">if</span>([gradientLayer animationForKey:kAnimationKey] == <span class="literal">nil</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 通过不断改变渐变的起止范围，来实现光晕效果</span></span><br><span class="line">        <span class="built_in">CABasicAnimation</span> *startPointAnimation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:gradientStartPointKey];</span><br><span class="line">        startPointAnimation<span class="variable">.toValue</span> = [<span class="built_in">NSValue</span> valueWith<span class="built_in">CGPoint</span>:<span class="built_in">CGPointMake</span>(<span class="number">1.0</span>, <span class="number">0</span>)];</span><br><span class="line">        startPointAnimation<span class="variable">.timingFunction</span> = [<span class="built_in">CAMediaTimingFunction</span> functionWithName:_animationPacing];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CABasicAnimation</span> *endPointAnimation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:gradientEndPointKey];</span><br><span class="line">        endPointAnimation<span class="variable">.toValue</span> = [<span class="built_in">NSValue</span> valueWith<span class="built_in">CGPoint</span>:<span class="built_in">CGPointMake</span>(<span class="number">1</span> + pHaloWidth, <span class="number">0</span>)];</span><br><span class="line">        endPointAnimation<span class="variable">.timingFunction</span> = [<span class="built_in">CAMediaTimingFunction</span> functionWithName:_animationPacing];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CAAnimationGroup</span> *group = [<span class="built_in">CAAnimationGroup</span> animation];</span><br><span class="line">        group<span class="variable">.animations</span> = @[startPointAnimation, endPointAnimation];</span><br><span class="line">        group<span class="variable">.duration</span> = pHaloDuration;</span><br><span class="line">        group<span class="variable">.timingFunction</span> = [<span class="built_in">CAMediaTimingFunction</span> functionWithName:_animationPacing];</span><br><span class="line">        group<span class="variable">.repeatCount</span> = HUGE_VALF;</span><br><span class="line">        </span><br><span class="line">        [gradientLayer addAnimation:group forKey:kAnimationKey];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="使用">使用</h1><h3 id="安装">安装</h3><ul>
<li>添加 <code>pod &#39;PDPullToRefresh&#39;</code> 到你的 Podfile ，然后<code>pod install</code>。</li>
<li>手动添加到你的Xcode项目中，<code>#import &quot;PDPullToRefresh.h&quot;</code>。</li>
</ul>
<h3 id="添加下拉刷新">添加下拉刷新</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[tableView <span class="string">pd_addHeaderRefreshWithNavigationBar:</span>YES <span class="string">andActionHandler:</span>^&#123;</span><br><span class="line">    <span class="comment">// prepend data to dataSource, insert cells at top of table view</span></span><br><span class="line">    <span class="comment">// call [tableView.pdHeaderRefreshView stopRefreshing] when done</span></span><br><span class="line"> &#125;];</span><br></pre></td></tr></table></figure>
<h3 id="添加上拉刷新">添加上拉刷新</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[tableView <span class="string">pd_addFooterRefreshWithNavigationBar:</span>YES <span class="string">andActionHandler:</span>^&#123;</span><br><span class="line">    <span class="comment">// prepend data to dataSource, insert cells at top of table view</span></span><br><span class="line">    <span class="comment">// call [tableView.pdFooterRefreshView stopRefreshing] when done</span></span><br><span class="line"> &#125;];</span><br></pre></td></tr></table></figure>
<h3 id="立即刷新">立即刷新</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">[tableView.pdHeaderRefreshView startRefreshing]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h3 id="自定义">自定义</h3><p>目前仅支持下拉距离自定义，默认高度为80</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> pdHeaderRefreshViewHeight;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> pdFooterRefreshViewHeight;</span><br></pre></td></tr></table></figure>
<h1 id="最后">最后</h1><p>附上<a href="https://github.com/v2panda/PDPullToRefresh" target="_blank" rel="external">Github地址</a>，外加感谢<a href="https://itunes.apple.com/cn/app/ban-tang/id955357564?mt=8" target="_blank" rel="external">半糖</a>、<a href="https://github.com/samvermette/SVPullToRefresh" target="_blank" rel="external">SVPullToRefresh</a>对我的启发。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;周末仿写了半糖的下拉刷新，学了两句法语&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C’est La Vie    &lt;/li&gt;
&lt;li&gt;La Vie est belle&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C’est La Vie 通常是用在较为消极的事情发生时，用于自我安慰或自我解嘲，鼓励自己或他人即使遇到了再大的难处，也要坦然笑对生活。鸡汤一下，开始正文。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xnmlk.com1.z0.glb.clouddn.com/2015-cheers.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2015 - 开端</title>
    <link href="http://v2panda.com/2015/12/26/2015-summary/"/>
    <id>http://v2panda.com/2015/12/26/2015-summary/</id>
    <published>2015-12-26T07:25:29.000Z</published>
    <updated>2015-12-29T13:36:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>这一年毕业了，告别了可能是人生最自由的时光。这一年工作了，由学生成为了职业工作者。现在是26号，离本命年就剩几天了，有些忐忑，有些感悟，有些吐槽，在这里记录一下我的2015。意识流——想到哪里——说到哪里。</p>
<a id="more"></a>
<h3 id="工作">工作</h3><p>2015是我正式工作的第一年，正式工作跟之前大半年的实习生活完全不同。实习时写的东西规模都很小，技术含量也不高，基本上都是在自学瞎鼓捣。正式工作后真正领略到了企业项目开发的艰辛，团队协作的魅力，以及一个好团队的重要性。这种益处不仅仅体现在工作上，还能在生活上让你有个好心情。</p>
<p>庆幸的是我正身处与这样的团队中，团队里轻松融洽的氛围是我每天工作的动力，简单的说就是一口气改10个bug，都不费劲儿。这在我实习的公司是完全不能想象的，那里仿佛人与人之间都有道墙，没有任何工作之外的事情交流。所以在毕业时没有接受前老大的挽留留在那，当然还是得感谢实习的公司，在那里我学到了很多在学校学不到的东西，也是在那里学会了碰到问题，你应该去解决它，而不是选择逃避。然而那段时间的经历极为宝贵，感谢他们对我的无私帮助与耐心。</p>
<h3 id="学习">学习</h3><p>talk is cheap,show me the code.这话是Linus Torvalds说的。我的理解是多做事少BB，简单的是先做再说。<br>学习在我实习之后就成了我生命中的主线，很惭愧在学校中没投入100%精力在学习上。然而工作后对学习的渴求比在学校更加强烈，有太多东西不知道，太多东西不熟悉，太多东西不会。最可怕的是模棱两可的认知，刚工作时说的最多的就是我想是这样，我觉得是这样。别人问能确定吗？我并不能，然后就会羞愧的回去看代码、看文档、查资料、请教同事直到彻底搞清楚为止。</p>
<p>也会常常会感到每天的提升太慢，想学的东西好太多，Android很有意思，前端也有趣，PHP世界上最好的语言我竟然不会。所以平常也会看一些相关的博客文章，但大多都浅尝辄止，没有深入。我强迫自己冷静下来，明确自己的主要任务是什么，想到Swift都没玩熟练，哪有时间去搞Android搞前端，学习重要的是循序渐进，一步一步来。</p>
<p>很羞愧在学校没有好好学习英语，致使我现在不太能无障碍的阅读。虽然常常借助翻译，但很多英文文章，不论是技术上的还是生活上的，都深深的改变了我对这个世界的认识，打开了另一扇窗户。学习的道路上还有许多需要努力，英语是必不可少的一部分。</p>
<h3 id="成长">成长</h3><p>技术方面相对于在校成长了不少，但离自己的期望还有不少差距。</p>
<p>交际方面基本没有什么成长，来北京后太宅了，这也是明年重点要解决的问题。</p>
<h3 id="博客">博客</h3><p>以前都是在博客园简单的写写画画，copy&amp;paste代码，完全没有章法，现在有了固定的地方很高兴能把博客坚持下来。虽然文笔很烂很多内容深度不够，文字组织的也不好，但我还是很兴奋，因为这里是记录我所思所想的自留地。有时非常羡慕那些文笔好的人，可以自由自在地用文字抒发自己的想法和情感，因此虽然是个程序员，还是想文艺点。建立这个博客记录下日常的点点滴滴，不论是技术上的还是生活上的，如同每个人对每件事的理解和感悟都不同，我能做的是在这里记录下我的亲身经历。今年的博客写得比较少，可能是因为忙，工作后没时间了。16年，每个月一定至少会有一篇。</p>
<p>在这里贴上唐巧的一篇文章<a href="http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&amp;mid=440158123&amp;idx=2&amp;sn=f61b9cd6948edd7109662aafd3e147e2&amp;3rd=MzA3MDU4NTYzMw==&amp;scene=6#rd" target="_blank" rel="external">作为码农，我们为什么要写作</a>。</p>
<h3 id="阅读">阅读</h3><h5 id="纸质书">纸质书</h5><p><img src="http://7xnmlk.com1.z0.glb.clouddn.com/2015summary.png" alt="图"></p>
<h5 id="电子书">电子书</h5><ul>
<li><p><a href="http://book.douban.com/subject/6709809/" target="_blank" rel="external">暗时间</a></p>
</li>
<li><p><a href="http://book.douban.com/subject/6709783/" target="_blank" rel="external">浪潮之巅</a></p>
</li>
<li><p><a href="https://gumroad.com/l/JnWS" target="_blank" rel="external">A GUIDE TO IOS ANIMATION</a></p>
</li>
<li><p><a href="https://selfstore.io/products/171" target="_blank" rel="external">Swifter</a></p>
</li>
<li><p><a href="http://shop.oreilly.com/product/0636920044352.do" target="_blank" rel="external">Programming iOS 9</a></p>
</li>
<li><p><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097-CH3-ID0" target="_blank" rel="external">The Swift Programming Language</a></p>
</li>
</ul>
<p>电子书还有一部分没看完，但总的来说还是看的太少了，打算在16年读一些深入的专业书籍。</p>
<h3 id="最后">最后</h3><blockquote>
<p>忙活了一年,</p>
<blockquote>
<p>梦想近了还是远了？远了。 </p>
<blockquote>
<p>年初制定的计划都实施了吗？没有。 </p>
<blockquote>
<p>bug改完了吗？没有。</p>
<blockquote>
<p>数据修完了吗？没有。</p>
<blockquote>
<p>饭少吃一口了吗，没有。</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>微博上看到这句话觉得好贴切，2015虽留有遗憾，但新的一年快到了，加油2016，愿新的一年里，我可以沉迷学习无法自拔。<img src="http://7xnmlk.com1.z0.glb.clouddn.com/2015-cheers.jpg" alt="12"></p>
<p>最后，好好找个女票。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一年毕业了，告别了可能是人生最自由的时光。这一年工作了，由学生成为了职业工作者。现在是26号，离本命年就剩几天了，有些忐忑，有些感悟，有些吐槽，在这里记录一下我的2015。意识流——想到哪里——说到哪里。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何仿写一个App</title>
    <link href="http://v2panda.com/2015/12/06/how-to-imitation-app/"/>
    <id>http://v2panda.com/2015/12/06/how-to-imitation-app/</id>
    <published>2015-12-06T12:47:37.000Z</published>
    <updated>2015-12-14T09:20:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>最近看到一篇文章<a href="http://www.infoq.com/cn/news/2015/11/ibireme-interview?utm_source=infoq&amp;utm_medium=popular_widget&amp;utm_campaign=popular_content_list&amp;utm_content=homepage" target="_blank" rel="external">专访YYKit作者郭曜源：开源大牛是怎样炼成的</a>,其中 <a href="http://weibo.com/239801242" target="_blank" rel="external">ibireme</a>提到了他的学习方法，一个就是大量地阅读优秀项目的源代码，另一个就是自己动手实践来尝试。这非常值得学习，对我来说，沉下心来好好写代码才是提高姿势水平的上策，Talk is cheap, Show me the code!<br>这篇blog主要记录仿写一个App的准备工作,这里以美团为例。</p>
<a id="more"></a>
<h1 id="素材">素材</h1><p>首先到iTunes下载美团到本地<br><img src="http://7xnmlk.com1.z0.glb.clouddn.com/blog-how-to-imitation-app屏幕快照%202015-12-01%20下午5.57.20.png" alt="在Finder中显示"></p>
<p>在Finder中显示,解压ipa文件<br><img src="http://7xnmlk.com1.z0.glb.clouddn.com/blog-how-to-imitation-app屏幕快照%202015-12-01%20下午5.53.53.png" alt="解压ipa"><br>点击imeituan，显示包内容<br><img src="http://7xnmlk.com1.z0.glb.clouddn.com/blog-how-to-imitation-app屏幕快照%202015-12-01%20下午5.54.07.png" alt="显示包内容"><br>就能随意查看imeituan的素材内容。<br><img src="http://7xnmlk.com1.z0.glb.clouddn.com/blog-how-to-imitation-app屏幕快照%202015-12-01%20下午5.54.26.png" alt="素材"></p>
<h1 id="接口">接口</h1><ul>
<li><a href="https://www.charlesproxy.com/" target="_blank" rel="external">Charles</a><br>这是一款在 Mac 下常用的网络封包截取工具，Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成,这里我们主要用它来截取网络封包来分析。</li>
</ul>
<p>这里我们主要截取iPhone上App的网络请求，所以使用 Charles 的第一步在菜单栏上选择 “Proxy”–&gt;“Proxy Settings”，填入代理端口 8888，并且勾上 “Enable transparent HTTP proxying” 就完成了在 Charles 上的设置。如下图所示:<br><img src="http://7xnmlk.com1.z0.glb.clouddn.com/blog-how-to-imitation-app屏幕快照%202015-12-01%20下午5.36.11.png" alt="Proxy"><br>然后我们需要获取 Charles 运行所在电脑的 IP 地址，Charles 的顶部菜单的 “Help”–&gt;“Local IP Address”，即可在弹出的对话框中看到 IP 地址，如下图所示：<br><img src="http://7xnmlk.com1.z0.glb.clouddn.com/blog-how-to-imitation-app屏幕快照%202015-12-01%20下午5.36.53.png" alt="IP"></p>
<p>最后在 iPhone 的「HTTP 代理」，将其切换成手动，然后填上 Charles 运行所在的电脑的 IP，以及端口号 8888，如下图所示：<br><img src="http://7xnmlk.com1.z0.glb.clouddn.com/blog-how-to-imitation-appUntitled3.png" alt="8888"></p>
<p>接下来在手机上运行美团，就能再Charles上查看网络请求，如下所示：<br><img src="http://7xnmlk.com1.z0.glb.clouddn.com/blog-how-to-imitation-app屏幕快照%202015-12-01%20下午5.51.13.png" alt="flurry"><br><img src="http://7xnmlk.com1.z0.glb.clouddn.com/blog-how-to-imitation-app屏幕快照%202015-12-01%20下午5.52.48.png" alt="http"><br>这是美团启动是Charles的显示，可以看到<code>http://data.flurry.com</code>的请求，显而易见美团iOS是使用flurry统计数据的。关于Charles详细使用方法可以查看<a href="http://blog.devtang.com/blog/2015/11/14/charles-introduction/" target="_blank" rel="external">这篇博客</a>。</p>
<h1 id="App结构">App结构</h1><p>这里使用Reaveal + iPhone(越狱)来分析App的UI视图结构。</p>
<p>准备工作：<br>1.iPhone越狱。<br>2.越狱后iPhone上会自行安装上Cydia商店，打开Cydia，先在tabBar的“变更”页面刷新软件源。刷新成功后用Cydia搜索并安装Reveal loader ，安装完成后点击重启springboard。</p>
<p><img src="http://7xnmlk.com1.z0.glb.clouddn.com/blog-how-to-imitation-appUntitled.png" alt="Reveal loader"></p>
<p>3.在系统设置中找到Reveal，点击Reveal - Enabled Applications，将美团选为Enabled。</p>
<p><img src="http://7xnmlk.com1.z0.glb.clouddn.com/blog-how-to-imitation-appUntitled2.png" alt="Enabled"></p>
<p>4.安装<a href="http://revealapp.com/" target="_blank" rel="external">Reveal</a>。<br>5.首先保证iPhone和Mac在同一局域网（WiFi）中，在iPhone中运行你要监视的app，如果app已经运行，需在后台杀死进程重新打开，保持app在前台，然后在Mac中打开Reveal，点击左上角的No Connection，然后选择即可。<br>6.Commend+5 切换3D模式。每当iPhone上的app页面切换后，需要点击Reveal窗口右上角刷新（Commend+R）。在局域网内负荷较大时，视图刷新会很慢，可以用iPhone共享热点给Mac解决。</p>
<p>准备完毕后，就能在Reveal上随意查看App结构了，如下图所示:<br><img src="http://7xnmlk.com1.z0.glb.clouddn.com/blog-how-to-imitation-app屏幕快照%202015-12-01%20下午5.56.41.png" alt="App结构"></p>
<h1 id="后记">后记</h1><p>这篇blog主要记录仿写一个App的准备工作,包括获取素材，接口，以及查看App层级结构，关于如何仿写怎么仿写，就得自己去Coding了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;&lt;p&gt;最近看到一篇文章&lt;a href=&quot;http://www.infoq.com/cn/news/2015/11/ibireme-interview?utm_source=infoq&amp;amp;utm_medium=popular_widget&amp;amp;utm_campaign=popular_content_list&amp;amp;utm_content=homepage&quot;&gt;专访YYKit作者郭曜源：开源大牛是怎样炼成的&lt;/a&gt;,其中 &lt;a href=&quot;http://weibo.com/239801242&quot;&gt;ibireme&lt;/a&gt;提到了他的学习方法，一个就是大量地阅读优秀项目的源代码，另一个就是自己动手实践来尝试。这非常值得学习，对我来说，沉下心来好好写代码才是提高姿势水平的上策，Talk is cheap, Show me the code!&lt;br&gt;这篇blog主要记录仿写一个App的准备工作,这里以美团为例。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>自建网络调试工具</title>
    <link href="http://v2panda.com/2015/11/25/network-debugging-tools/"/>
    <id>http://v2panda.com/2015/11/25/network-debugging-tools/</id>
    <published>2015-11-25T07:30:51.000Z</published>
    <updated>2015-12-14T09:19:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>最近用的VPN越来越不稳定了，决定搭个小梯子自用。</p>
<table>
<thead>
<tr>
<th>My Choice</th>
<th style="text-align:center">Before</th>
<th style="text-align:center">Now</th>
</tr>
</thead>
<tbody>
<tr>
<td>Phone</td>
<td style="text-align:center">Hydro</td>
<td style="text-align:center">Surge</td>
</tr>
<tr>
<td>PC</td>
<td style="text-align:center">VPN + Lantern</td>
<td style="text-align:center">Shadowsocks</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<p>而在Surge上也是可以用Shadowsocks的，并且Shadowsocks有以下特点：</p>
<ul>
<li>省电，在电量查看里几乎看不到它的身影；</li>
<li>支持开机自启动，且断网无影响，无需手动重连，方便网络不稳定或者3G&amp;Wi-Fi频繁切换的小伙伴；</li>
<li>可使用自己的服务器，安全和速度的保证；</li>
<li>支持区分国内外流量，传统VPN在翻出墙外后访问国内站点会变慢；</li>
<li>可对应用设置单独代理，5.0之后的系统无需root。</li>
</ul>
<p>虽然由于<a href="http://www.freebuf.com/news/76451.html" target="_blank" rel="external">喝茶事件</a>，ss 的作者已经删除项目，不过目前还能用,所以搭建一个VPS安装Shadowsocks是我的最佳选择。</p>
<h1 id="VPS">VPS</h1><p>VPS有许许多多，但想要达到网络调试的目的还是得选择海外的服务器。<br>目前主流的VPS提供商有3个</p>
<ul>
<li>Banwagong</li>
<li>DigitalOcean</li>
<li>Linode</li>
</ul>
<p>若不知道如何选择，可以参考下表(比较的都是最低套餐)</p>
<table>
<thead>
<tr>
<th>VPS</th>
<th style="text-align:center">架构</th>
<th style="text-align:center">内存</th>
<th style="text-align:center">硬盘</th>
<th style="text-align:center">流量</th>
<th style="text-align:center">费用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Banwagong</td>
<td style="text-align:center">OpenVZ</td>
<td style="text-align:center">256M</td>
<td style="text-align:center">10G</td>
<td style="text-align:center">500G/M</td>
<td style="text-align:center">19.99 $/Y</td>
</tr>
<tr>
<td>DigitalOcean</td>
<td style="text-align:center">KVM</td>
<td style="text-align:center">512M</td>
<td style="text-align:center">20G</td>
<td style="text-align:center">1T/M</td>
<td style="text-align:center">5 $/M</td>
</tr>
<tr>
<td>Linode</td>
<td style="text-align:center">Xen</td>
<td style="text-align:center">1G</td>
<td style="text-align:center">24G</td>
<td style="text-align:center">2T/M</td>
<td style="text-align:center">10 $/M</td>
</tr>
</tbody>
</table>
<p>个人建议，对连接速度和稳定性尤其是网络延迟有极高要求的首选Linode，有较高要求的推荐DigitalOcean，对于普通用户来讲，搬瓦工就可以。<br>一般用 paypal 支付，因为用信用卡可能会要求你上传身份证明以及信用卡照片什么的，而且审核过程也需要等待，比较麻烦。注意要用国际 paypal 帐号，国内的是不能用外币付款的。</p>
<h1 id="Shadowsocks">Shadowsocks</h1><p>VPS选择完毕后，直接登录开始安装。</p>
<p>Mac OS X 或 Linux 下直接在终端中 ssh root@your_vps_ip -p your_ssh_port   即可。</p>
<p>Debian / Ubuntu:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get <span class="keyword">install</span> python-pip</span><br><span class="line">pip <span class="keyword">install</span> shadowsocks</span><br></pre></td></tr></table></figure>
<p>CentOS:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> python-setuptools &amp;&amp; easy_install pip</span><br><span class="line">pip <span class="keyword">install</span> shadowsocks</span><br></pre></td></tr></table></figure>
<p>配置</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "<span class="attribute">server</span>":<span class="value"><span class="string">"0.0.0.0"</span></span>,</span><br><span class="line">    "<span class="attribute">server_port</span>":<span class="value">yourport</span>,</span><br><span class="line">    "<span class="attribute">local_address</span>": <span class="value"><span class="string">"127.0.0.1"</span></span>,</span><br><span class="line">    "<span class="attribute">local_port</span>":<span class="value"><span class="number">1080</span></span>,</span><br><span class="line">    "<span class="attribute">password</span>":<span class="value"><span class="string">"yourpassword"</span></span>,</span><br><span class="line">    "<span class="attribute">timeout</span>":<span class="value"><span class="number">300</span></span>,</span><br><span class="line">    "<span class="attribute">method</span>":<span class="value"><span class="string">"aes-256-cfb"</span></span>,</span><br><span class="line">    "<span class="attribute">fast_open</span>": <span class="value"><span class="literal">false</span></span>,</span><br><span class="line">    "<span class="attribute">workers</span>": <span class="value"><span class="number">1</span></span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>使用</p>
<p><code>ssserver -p 443 -k password -m rc4-md5</code></p>
<p>后台运行：</p>
<p><code>sudo ssserver -p 443 -k password -m rc4-md5 --user nobody -d start</code></p>
<p>停止：</p>
<p><code>sudo ssserver -d stop</code></p>
<p>检查日志：</p>
<p><code>sudo less /var/log/shadowsocks.log</code></p>
<p>更具体的可以查看<a href="https://github.com/shadowsocks/shadowsocks/wiki/Shadowsocks-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E" target="_blank" rel="external">wiki</a>。</p>
<h1 id="Surge">Surge</h1><p>Surge 是基于 iOS 9 的新特性 <code>Network Extension</code> 开发的一款网络调试工具，工作原理是使用 Packet Tunnel Provider 给系统套上一个代理，Surge 有两个主要组件：Surge 代理服务器和 Surge TUN 接口。程序运行之后，Surge 会将自身设置为默认的 HTTP/HTTPS 代理服务器来处理所有的 HTTP/HTTPS 流量。针对一些不服从系统代理设置的应用程序 ，将由 Surge 的 TUN 接口来进行处理。</p>
<p>Surge具体的使用可以查看<a href="http://surge.run/manual/" target="_blank" rel="external">manual</a>，这里我们主要配置Surge在iOS上使用Shadowsocks。</p>
<p>如果需要使用shadowsocks，目前surge 通过module支持配置，具体配置规则类似下面的配置，具体的服务器、端口、加密方式、密码参照你自己的SS配置：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Proxy]</span><br><span class="line"></span><br><span class="line">Proxy = custom, IP, Port, <span class="function"><span class="keyword">Method</span>, <span class="title">password</span>, <span class="title">Module</span></span></span><br></pre></td></tr></table></figure>
<p>Proxy类型必须是custom，如果改成其他名称会报错，剩下的地址按照服务商提供的来填，最后要加上SS module的地址，目前surge 的官网已经删掉了module文件，可以从<a href="https://www.dropbox.com/s/jfvicg5omhlgg6g/SSEncrypt.module?dl=0" target="_blank" rel="external">这里</a>下载，下载后上传到你自己的网址。</p>
<h1 id="我的选择">我的选择</h1><p>我个人的选择供大家参考：</p>
<p>DigitalOcean，San Francisco节点，1TB流量。</p>
<p>若有想用DigitalOcean可以使用<a href="https://www.digitalocean.com/?refcode=93cc79d1d49b" target="_blank" rel="external">此链接</a>注册,可以得到10$。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;&lt;p&gt;最近用的VPN越来越不稳定了，决定搭个小梯子自用。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;My Choice&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Before&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Now&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Phone&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Hydro&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Surge&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PC&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;VPN + Lantern&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Shadowsocks&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
    
      <category term="Shadowsocks" scheme="http://v2panda.com/tags/Shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>滑动返回手势探究</title>
    <link href="http://v2panda.com/2015/10/13/research-slidingback-gesture/"/>
    <id>http://v2panda.com/2015/10/13/research-slidingback-gesture/</id>
    <published>2015-10-13T08:44:49.000Z</published>
    <updated>2015-12-14T09:18:07.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言">前言</h4><p>从iOS7开始，苹果增加了页面右滑返回的效果，具体的是以UINavigationController为容器的ViewController间右滑切换页面。</p>
<p>代码里的设置是：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span><span class="variable">.navigationController</span><span class="variable">.interactivePopGestureRecognizer</span><span class="variable">.enabled</span> = <span class="literal">YES</span>;（<span class="keyword">default</span> is <span class="literal">YES</span>）</span><br></pre></td></tr></table></figure>
<p>可以看到苹果给navigationController添加了一个手势（具体为<code>UIScreenEdgePanGestureRecognizer</code>（边缘手势，同样是ios7以后才有的）），就是利用这个手势实现的 iOS7的侧滑返回。</p>
<p>但在日常开发中，我们大多会自定义返回按钮，此时系统的右滑返回就会失效。然而支持滑动返回已成为iOS上必须实现的交互，若没有那APP离被卸载就不远了。</p>
<a id="more"></a>
<h4 id="设置interactivePopGestureRecognizer">设置interactivePopGestureRecognizer</h4><p>对于这种失效的情况，考虑到<code>interactivePopGestureRecognizer</code>也有delegate属性，替换默认的self.navigationController.interactivePopGestureRecognizer.delegate来配置右滑返回的表现也是可行的。我们可以在主NavigationController中设置一下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self<span class="class">.navigationController</span><span class="class">.interactivePopGestureRecognizer</span><span class="class">.delegate</span> =(id)self</span><br></pre></td></tr></table></figure>
<p>然而这样又会出现很多问题，比如说在rootViewController的时候这个手势也可以响应，导致整个程序页面不响应；push了多层后，快速的触发两次手势，也会错乱。</p>
<h4 id="最佳方案">最佳方案</h4><p>最佳方案参考自sunnyxx的博客，他是怎么做的呢。<br>通过设置interactivePopGestureRecognizer可以简单的实现，但又会出现很多问题，所以我们可以自己实现一个手势去替换掉系统的，运用</p>
<ul>
<li>runtime+KVC+AOP</li>
</ul>
<p>的方式，用KVC拿到interactivePopGestureRecognizer的target和action，用runtime动态替换掉，面向切面编程，不用在原工程上增删代码。</p>
<h4 id="实现">实现</h4><p>还是写码最省事，直接动手！</p>
<p>首先，创建一个UINavigationController的分类,再添加UIViewController的分类,在UINavigationController.h里声明自定义的手势，在UIViewController.h里声明<code>pda_interactivePopDisabled</code>是否显示手势和pda_interactivePopMaxAllowedInitialDistanceToLeftEdge手势滑动距左边最大的距离。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UINavigationController</span> (<span class="title">PDAPopGesture</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">UIPanGestureRecognizer</span> *pda_popGestureRecognizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIViewController</span> (<span class="title">PDAPopGesture</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> pda_interactivePopDisabled;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> pda_interactivePopMaxAllowedInitialDistanceToLeftEdge;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>在.m里定义一个私有类，设置手势的执行条件。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"UINavigationController+PDAPopGesture.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PDAFullscreenPopGestureRecognizerDelegate</span> : <span class="title">NSObject</span> &lt;<span class="title">UIGestureRecognizerDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">UINavigationController</span> *navigationController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PDAFullscreenPopGestureRecognizerDelegate</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)gestureRecognizerShouldBegin:(<span class="built_in">UIPanGestureRecognizer</span> *)gestureRecognizer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 当为根控制器时，手势不执行。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.navigationController</span><span class="variable">.viewControllers</span><span class="variable">.count</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置一个页面是否显示此手势，默认为NO 显示。</span></span><br><span class="line">    <span class="built_in">UIViewController</span> *topViewController = <span class="keyword">self</span><span class="variable">.navigationController</span><span class="variable">.viewControllers</span><span class="variable">.lastObject</span>;</span><br><span class="line">    <span class="keyword">if</span> (topViewController<span class="variable">.pda_interactivePopDisabled</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  手势滑动距左边框的距离超过maxAllowedInitialDistance 手势不执行。</span></span><br><span class="line">    <span class="built_in">CGPoint</span> beginningLocation = [gestureRecognizer locationInView:gestureRecognizer<span class="variable">.view</span>];</span><br><span class="line">    <span class="built_in">CGFloat</span> maxAllowedInitialDistance = topViewController<span class="variable">.pda_interactivePopMaxAllowedInitialDistanceToLeftEdge</span>;</span><br><span class="line">    <span class="keyword">if</span> (maxAllowedInitialDistance &gt; <span class="number">0</span> &amp;&amp; beginningLocation<span class="variable">.x</span> &gt; maxAllowedInitialDistance) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当push、pop动画正在执行时，手势不执行。</span></span><br><span class="line">    <span class="keyword">if</span> ([[<span class="keyword">self</span><span class="variable">.navigationController</span> valueForKey:<span class="string">@"_isTransitioning"</span>] boolValue]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  向左边(反方向)拖动，手势不执行。</span></span><br><span class="line">    <span class="built_in">CGPoint</span> translation = [gestureRecognizer translationInView:gestureRecognizer<span class="variable">.view</span>];</span><br><span class="line">    <span class="keyword">if</span> (translation<span class="variable">.x</span> &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>再在UINavigationController的实现里用Method Swizzling替换pushViewController方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+(void)load</span><br><span class="line">&#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        Class <span class="class"><span class="keyword">class</span> = [<span class="title">self</span> <span class="title">class</span>];</span></span><br><span class="line">        </span><br><span class="line">        SEL originalSelector = @selector(pushViewController:animated:);</span><br><span class="line">        SEL swizzledSelector = @selector(pda_pushViewController:animated:);</span><br><span class="line">        </span><br><span class="line">        Method originalMethod = class_getInstanceMethod(<span class="class"><span class="keyword">class</span>, <span class="typename">originalSelector);</span></span></span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(<span class="class"><span class="keyword">class</span>, <span class="typename">swizzledSelector);</span></span></span><br><span class="line">        </span><br><span class="line">        BOOL success = class_addMethod(<span class="class"><span class="keyword">class</span>, <span class="typename">originalSelector</span>, <span class="typename">method_getImplementation</span></span>(swizzledMethod), method_getTypeEncoding(swizzledMethod));</span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            class_replaceMethod(<span class="class"><span class="keyword">class</span>, <span class="typename">swizzledSelector</span>, <span class="typename">method_getImplementation</span></span>(originalMethod), method_getTypeEncoding(originalMethod));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是Method Swizzling API 提供的三个方法来动态替换类方法或实例方法。</p>
<ul>
<li>class_replaceMethod                         替换类方法的定义</li>
<li>method_exchangeImplementations   交换 2 个方法的实现</li>
<li>method_setImplementation               设置 1 个方法的实现</li>
</ul>
<p>而这三个又有些使用上的区别，class_replaceMethod, 当需要替换的方法可能有不存在的情况时，可以考虑使用该方法。method_exchangeImplementations，当需要交换 2 个方法的实现时使用。method_setImplementation 最简单的用法，当仅仅需要为一个方法设置其实现方式时使用。</p>
<p>所以这里得先确认添加的方法是否存在，举个具体的例子, 假设要替换掉[NSView description]方法，如果NSView 没有实现-description (可选的) 那你就可会得到NSObject的方法。 如果调用method_exchangeImplementations , 你就会把NSObject 的方法替换成你的代码，这显然不是我们想要的。</p>
<p>所以在这里定义一个BOOL值来接收class_addMethod的返回值，class_addMethod会动态的给类添加方法，若方法fd_viewWillAppear已存在，class_addMethod会返回失败，此时调用method_exchangeImplementations去替换，若不存在，则用class_replaceMethod替换。</p>
<p>继续实现pda_pushViewController:animated方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)pda_pushViewController:(<span class="built_in">UIViewController</span> *)viewController animated:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span><span class="variable">.interactivePopGestureRecognizer</span><span class="variable">.view</span><span class="variable">.gestureRecognizers</span> containsObject:<span class="keyword">self</span><span class="variable">.pda_popGestureRecognizer</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  添加我们自己的侧滑返回手势</span></span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.interactivePopGestureRecognizer</span><span class="variable">.view</span> addGestureRecognizer:<span class="keyword">self</span><span class="variable">.pda_popGestureRecognizer</span>];</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         新建一个UIPanGestureRecognizer，让它的触发和系统的这个手势相同，</span><br><span class="line">         这就需要利用runtime获取系统手势的target和action。</span><br><span class="line">         */</span></span><br><span class="line">        <span class="comment">//  用KVC取出target和action</span></span><br><span class="line">        <span class="built_in">NSArray</span> *internalTargets = [<span class="keyword">self</span><span class="variable">.interactivePopGestureRecognizer</span> valueForKey:<span class="string">@"targets"</span>];</span><br><span class="line">        <span class="keyword">id</span> internalTarget = [internalTargets<span class="variable">.firstObject</span> valueForKey:<span class="string">@"target"</span>];</span><br><span class="line">        SEL internalAction = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"handleNavigationTransition:"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  将自定义的代理（手势执行条件）传给手势的delegate</span></span><br><span class="line">        <span class="keyword">self</span><span class="variable">.pda_popGestureRecognizer</span><span class="variable">.delegate</span> = <span class="keyword">self</span><span class="variable">.pda_popGestureRecognizerDelegate</span>;</span><br><span class="line">        <span class="comment">//  将target和action传给手势</span></span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.pda_popGestureRecognizer</span> addTarget:internalTarget action:internalAction];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  设置系统的为NO</span></span><br><span class="line">        <span class="keyword">self</span><span class="variable">.interactivePopGestureRecognizer</span><span class="variable">.enabled</span> = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  执行原本的方法</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span><span class="variable">.viewControllers</span> containsObject:viewController]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> pda_pushViewController:viewController animated:animated];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中要注意的是将前面定义的手势触发条件的delegate传给pda_popGestureRecognizer的delegate。</p>
<p>最后补上pda_popGestureRecognizer的getter和pda_popGestureRecognizerDelegate的setter方法。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- <span class="list">(<span class="keyword">PDAFullscreenPopGestureRecognizerDelegate</span> <span class="variable">*)pda_popGestureRecognizerDelegate</span><br><span class="line">&#123;</span><br><span class="line">    PDAFullscreenPopGestureRecognizerDelegate *</span>delegate = objc_getAssociatedObject<span class="list">(<span class="keyword">self</span>, _cmd)</span><span class="comment">;</span></span><br><span class="line">    if <span class="list">(!delegate)</span> &#123;</span><br><span class="line">        delegate = [[PDAFullscreenPopGestureRecognizerDelegate alloc] init]<span class="comment">;</span></span><br><span class="line">        delegate.navigationController = self<span class="comment">;</span></span><br><span class="line">        objc_setAssociatedObject<span class="list">(<span class="keyword">self</span>, _cmd, delegate, OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    return delegate<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- <span class="list">(<span class="keyword">UIPanGestureRecognizer</span> <span class="variable">*)pda_fullscreenPopGestureRecognizer</span><br><span class="line">&#123;</span><br><span class="line">    UIPanGestureRecognizer *</span>panGestureRecognizer = objc_getAssociatedObject<span class="list">(<span class="keyword">self</span>, _cmd)</span><span class="comment">;</span></span><br><span class="line">    if <span class="list">(!panGestureRecognizer)</span> &#123;</span><br><span class="line">        panGestureRecognizer = [[UIPanGestureRecognizer alloc] init]<span class="comment">;</span></span><br><span class="line">        panGestureRecognizer.maximumNumberOfTouches = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">        objc_setAssociatedObject<span class="list">(<span class="keyword">self</span>, _cmd, panGestureRecognizer, OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    return panGestureRecognizer<span class="comment">;</span></span><br><span class="line">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>后面UIViewController只需要给出<code>pda_interactivePopMaxAllowedInitialDistanceToLeftEdge</code><br>和<code>pda_interactivePopDisabled</code>的setter和getter即可。</p>
<h4 id="后记">后记</h4><p>大功告成，直接添加到工程里，不用额外代码即可为你的项目添加滑动返回效果，快去试试吧！</p>
<h4 id="参考链接">参考链接</h4><p><a href="http://blog.sunnyxx.com/2015/06/07/fullscreen-pop-gesture/" target="_blank" rel="external">http://blog.sunnyxx.com/2015/06/07/fullscreen-pop-gesture/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;前言&lt;/h4&gt;&lt;p&gt;从iOS7开始，苹果增加了页面右滑返回的效果，具体的是以UINavigationController为容器的ViewController间右滑切换页面。&lt;/p&gt;
&lt;p&gt;代码里的设置是：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.navigationController&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.interactivePopGestureRecognizer&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.enabled&lt;/span&gt; = &lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;;（&lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; is &lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;）&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以看到苹果给navigationController添加了一个手势（具体为&lt;code&gt;UIScreenEdgePanGestureRecognizer&lt;/code&gt;（边缘手势，同样是ios7以后才有的）），就是利用这个手势实现的 iOS7的侧滑返回。&lt;/p&gt;
&lt;p&gt;但在日常开发中，我们大多会自定义返回按钮，此时系统的右滑返回就会失效。然而支持滑动返回已成为iOS上必须实现的交互，若没有那APP离被卸载就不远了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://v2panda.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>链式编程初探</title>
    <link href="http://v2panda.com/2015/09/29/chain-programming/"/>
    <id>http://v2panda.com/2015/09/29/chain-programming/</id>
    <published>2015-09-29T08:44:49.000Z</published>
    <updated>2015-12-14T06:43:57.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言">前言</h4><p>最近学习了下<a href="https://github.com/SnapKit/Masonry" target="_blank" rel="external">masonry</a>的源码,看到有许多如</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">make</span><span class="class">.top</span><span class="class">.equalTo</span>(<span class="tag">self</span><span class="class">.mas_topLayoutGuide</span>); </span><br><span class="line"><span class="tag">make</span><span class="class">.left</span><span class="class">.equalTo</span>(<span class="tag">self</span><span class="class">.view</span>);</span><br><span class="line"><span class="tag">make</span><span class="class">.right</span><span class="class">.equalTo</span>(<span class="tag">self</span><span class="class">.view</span>);</span><br><span class="line"><span class="tag">make</span><span class="class">.height</span><span class="class">.equalTo</span>(<span class="at_rule">@<span class="keyword">40);</span></span></span><br></pre></td></tr></table></figure>
<p>这样的代码，对这种链式的写法很感兴趣，所以准备研究一下，学习它的编程思想。</p>
<a id="more"></a>
<h4 id="链式编程思想">链式编程思想</h4><p>是将多个操作（多行代码）通过点号(.)链接在一起成为一句代码,使代码可读性好。如a(1).b(2).c(3)</p>
<h4 id="链式编程特点">链式编程特点</h4><p>方法的返回值是block,block必须有返回值（本身对象），block参数（需要操作的值）</p>
<h4 id="实战">实战</h4><p>模仿masonry，写一个加法计算器，练习链式编程。</p>
<p>1.新建类。</p>
<p><img src="http://7xnmlk.com1.z0.glb.clouddn.com/234048-193e56372a1f9b54.png" alt="a.png"></p>
<p>2.在CaculatorMaker.h里定义四则运算</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">interface</span> <span class="type">CaculatorMaker</span> : <span class="type">NSObject</span></span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) <span class="type">int</span> <span class="literal">result</span>;</span><br><span class="line"></span><br><span class="line">- (<span class="type">CaculatorMaker</span> *(^)(<span class="type">int</span>))add;</span><br><span class="line">- (<span class="type">CaculatorMaker</span> *(^)(<span class="type">int</span>))sub;</span><br><span class="line">- (<span class="type">CaculatorMaker</span> *(^)(<span class="type">int</span>))multi;</span><br><span class="line">- (<span class="type">CaculatorMaker</span> *(^)(<span class="type">int</span>))divide;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>3.在CaculatorMaker.m里实现</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">CaculatorMaker</span> *(^)(<span class="type">int</span>))add</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ^id(<span class="type">int</span> x) &#123;</span><br><span class="line">        self.<span class="literal">result</span> += x;</span><br><span class="line">        <span class="keyword">return</span> self;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.定义运算方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">CaculatorMaker</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">Caculator</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">int</span>)makeCaculators:(<span class="keyword">void</span>(^)(CaculatorMaker *maker))caculatorMaker;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>5.实现</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">int</span>)makeCaculators:(<span class="type">void</span>(^)(<span class="type">CaculatorMaker</span> *maker))caculatorMaker</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">CaculatorMaker</span> *maker = [[<span class="type">CaculatorMaker</span> alloc]init];</span><br><span class="line">    caculatorMaker(maker);</span><br><span class="line">    <span class="keyword">return</span> maker.<span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6.最后就能随意调用了</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="literal">result</span> = [<span class="type">NSObject</span> makeCaculators:^(<span class="type">CaculatorMaker</span> *maker) &#123;</span><br><span class="line">        maker.add(<span class="number">1</span>).add(<span class="number">1</span>).add(<span class="number">3</span>).multi(<span class="number">3</span>).sub(<span class="number">5</span>).divide(<span class="number">2</span>);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<h4 id="后记">后记</h4><p>非常简单的代码，初步的接触了下链式编程，感觉这种编程方式很爽，分享给大家。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;前言&lt;/h4&gt;&lt;p&gt;最近学习了下&lt;a href=&quot;https://github.com/SnapKit/Masonry&quot;&gt;masonry&lt;/a&gt;的源码,看到有许多如&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.top&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.equalTo&lt;/span&gt;(&lt;span class=&quot;tag&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.mas_topLayoutGuide&lt;/span&gt;); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.left&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.equalTo&lt;/span&gt;(&lt;span class=&quot;tag&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.view&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.right&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.equalTo&lt;/span&gt;(&lt;span class=&quot;tag&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.view&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.height&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.equalTo&lt;/span&gt;(&lt;span class=&quot;at_rule&quot;&gt;@&lt;span class=&quot;keyword&quot;&gt;40);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样的代码，对这种链式的写法很感兴趣，所以准备研究一下，学习它的编程思想。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程思想" scheme="http://v2panda.com/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
</feed>
