<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[v2panda's blog]]></title>
  <subtitle><![CDATA[subtitle]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://v2panda.com/"/>
  <updated>2015-10-20T06:53:17.000Z</updated>
  <id>http://v2panda.com/</id>
  
  <author>
    <name><![CDATA[熊猫]]></name>
    <email><![CDATA[pdxuzhen@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[滑动返回手势探究]]></title>
    <link href="http://v2panda.com/2015/10/13/%E6%BB%91%E5%8A%A8%E8%BF%94%E5%9B%9E%E6%89%8B%E5%8A%BF%E6%8E%A2%E7%A9%B6/"/>
    <id>http://v2panda.com/2015/10/13/滑动返回手势探究/</id>
    <published>2015-10-13T06:52:02.000Z</published>
    <updated>2015-10-20T06:53:17.000Z</updated>
    <content type="html"><![CDATA[<p>前言</p>
<p>从iOS7开始，苹果增加了页面右滑返回的效果，具体的是以UINavigationController为容器的ViewController间右滑切换页面。</p>
<p>代码里的设置是：</p>
<p>self.navigationController.interactivePopGestureRecognizer.enabled = YES;（default is YES）<br>可以看到苹果给navigationController添加了一个手势（具体为UIScreenEdgePanGestureRecognizer（边缘手势，同样是ios7以后才有的）），就是利用这个手势实现的 iOS7的侧滑返回。</p>
<p>但在日常开发中，我们大多会自定义返回按钮，此时系统的右滑返回就会失效。然而支持滑动返回已成为iOS上必须实现的交互，若没有那APP离被卸载就不远了。</p>
<p>设置interactivePopGestureRecognizer</p>
<p>对于这种失效的情况，考虑到interactivePopGestureRecognizer也有delegate属性，替换默认的self.navigationController.interactivePopGestureRecognizer.delegate来配置右滑返回的表现也是可行的。我们可以在主NavigationController中设置一下：</p>
<p>self.navigationController.interactivePopGestureRecognizer.delegate =(id)self<br>然而这样又会出现很多问题，比如说在rootViewController的时候这个手势也可以响应，导致整个程序页面不响应；push了多层后，快速的触发两次手势，也会错乱。</p>
<p>最佳方案</p>
<p>通过设置interactivePopGestureRecognizer可以简单的实现，但又会出现很多问题，所以我们可以自己实现一个手势去替换掉系统的，运用</p>
<p>runtime+KVC+AOP</p>
<p>的方式，用KVC拿到interactivePopGestureRecognizer的target和action，用runtime动态替换掉，面向切面编程，不用在原工程上增删代码。</p>
<p>实现</p>
<p>还是写码最省事，直接动手！</p>
<p>首先，创建一个UINavigationController的分类,再添加UIViewController的分类,在UINavigationController.h里声明自定义的手势，在UIViewController.h里声明pda_interactivePopDisabled是否显示手势和pda_interactivePopMaxAllowedInitialDistanceToLeftEdge手势滑动距左边最大的距离。</p>
<p>#import <uikit uikit.h=""></uikit></p>
<p>@interface UINavigationController (PDAPopGesture)</p>
<p>@property (nonatomic, strong, readonly) UIPanGestureRecognizer *pda_popGestureRecognizer;</p>
<p>@end</p>
<p>@interface UIViewController (PDAPopGesture)</p>
<p>@property (nonatomic, assign) BOOL pda_interactivePopDisabled;</p>
<p>@property (nonatomic, assign) CGFloat pda_interactivePopMaxAllowedInitialDistanceToLeftEdge;</p>
<p>@end<br>在.m里定义一个私有类，设置手势的执行条件。</p>
<p>#import “UINavigationController+PDAPopGesture.h”</p>
<p>#import <objc runtime.h=""></objc></p>
<p>@interface PDAFullscreenPopGestureRecognizerDelegate : NSObject <uigesturerecognizerdelegate></uigesturerecognizerdelegate></p>
<p>@property (nonatomic, weak) UINavigationController *navigationController;</p>
<p>@end</p>
<p>@implementation PDAFullscreenPopGestureRecognizerDelegate</p>
<ul>
<li><p>(BOOL)gestureRecognizerShouldBegin:(UIPanGestureRecognizer *)gestureRecognizer<br>{<br>  // 当为根控制器时，手势不执行。<br>  if (self.navigationController.viewControllers.count &lt;= 1) {</p>
<pre><code><span class="keyword">return</span> <span class="literal">NO</span>;
</code></pre><p>  }</p>
<p>  // 设置一个页面是否显示此手势，默认为NO 显示。<br>  UIViewController *topViewController = self.navigationController.viewControllers.lastObject;<br>  if (topViewController.pda_interactivePopDisabled) {</p>
<pre><code><span class="keyword">return</span> <span class="literal">NO</span>;
</code></pre><p>  }</p>
<p>  //  手势滑动距左边框的距离超过maxAllowedInitialDistance 手势不执行。<br>  CGPoint beginningLocation = [gestureRecognizer locationInView:gestureRecognizer.view];<br>  CGFloat maxAllowedInitialDistance = topViewController.pda_interactivePopMaxAllowedInitialDistanceToLeftEdge;<br>  if (maxAllowedInitialDistance &gt; 0 &amp;&amp; beginningLocation.x &gt; maxAllowedInitialDistance) {</p>
<pre><code><span class="keyword">return</span> <span class="literal">NO</span>;
</code></pre><p>  }</p>
<p>  // 当push、pop动画正在执行时，手势不执行。<br>  if ([[self.navigationController valueForKey:@”_isTransitioning”] boolValue]) {</p>
<pre><code><span class="keyword">return</span> <span class="literal">NO</span>;
</code></pre><p>  }</p>
<p>  //  向左边(反方向)拖动，手势不执行。<br>  CGPoint translation = [gestureRecognizer translationInView:gestureRecognizer.view];<br>  if (translation.x &lt;= 0) {</p>
<pre><code><span class="keyword">return</span> <span class="literal">NO</span>;
</code></pre><p>  }</p>
<p>  return YES;<br>}</p>
</li>
</ul>
<p>@end<br>再在UINavigationController的实现里用Method Swizzling替换pushViewController方法。</p>
<p>+(void)load<br>{<br>    static dispatch_once_t onceToken;<br>    dispatch_once(&amp;onceToken, ^{<br>        Class class = [self class];</p>
<pre><code>    SEL originalSelector = @<span class="keyword">selector</span>(pushViewController:animated:);
    SEL swizzledSelector = @<span class="keyword">selector</span>(pda_pushViewController:animated:);

    <span class="function"><span class="keyword">Method</span> <span class="title">originalMethod</span> = <span class="title">class_getInstanceMethod</span><span class="params">(<span class="keyword">class</span>, originalSelector)</span>;</span>
    <span class="function"><span class="keyword">Method</span> <span class="title">swizzledMethod</span> = <span class="title">class_getInstanceMethod</span><span class="params">(<span class="keyword">class</span>, swizzledSelector)</span>;</span>

    BOOL success = class_addMethod(<span class="keyword">class</span>, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));
    <span class="keyword">if</span> (success) <span class="comment">{
        class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));
    }</span> <span class="keyword">else</span> <span class="comment">{
        method_exchangeImplementations(originalMethod, swizzledMethod);
    }</span>
});
</code></pre><p>}<br>这里需要注意的是Method Swizzling API 提供的三个方法来动态替换类方法或实例方法。</p>
<p>class_replaceMethod                         替换类方法的定义</p>
<p>method_exchangeImplementations   交换 2 个方法的实现</p>
<p>method_setImplementation               设置 1 个方法的实现</p>
<p>而这三个又有些使用上的区别，class_replaceMethod, 当需要替换的方法可能有不存在的情况时，可以考虑使用该方法。method_exchangeImplementations，当需要交换 2 个方法的实现时使用。method_setImplementation 最简单的用法，当仅仅需要为一个方法设置其实现方式时使用。</p>
<p>所以这里得先确认添加的方法是否存在，举个具体的例子, 假设要替换掉[NSView description]方法，如果NSView 没有实现-description (可选的) 那你就可会得到NSObject的方法。 如果调用method_exchangeImplementations , 你就会把NSObject 的方法替换成你的代码，这显然不是我们想要的。</p>
<p>所以在这里定义一个BOOL值来接收class_addMethod的返回值，class_addMethod会动态的给类添加方法，若方法fd_viewWillAppear已存在，class_addMethod会返回失败，此时调用method_exchangeImplementations去替换，若不存在，则用class_replaceMethod替换。</p>
<p>继续实现pda_pushViewController:animated方法</p>
<ul>
<li><p>(void)pda_pushViewController:(UIViewController *)viewController animated:(BOOL)animated<br>{<br>  if (![self.interactivePopGestureRecognizer.view.gestureRecognizers containsObject:self.pda_popGestureRecognizer])<br>  {</p>
<pre><code><span class="comment">//  添加我们自己的侧滑返回手势</span>
[<span class="keyword">self</span><span class="variable">.interactivePopGestureRecognizer</span><span class="variable">.view</span> addGestureRecognizer:<span class="keyword">self</span><span class="variable">.pda_popGestureRecognizer</span>];
<span class="comment">/*
 新建一个UIPanGestureRecognizer，让它的触发和系统的这个手势相同，
 这就需要利用runtime获取系统手势的target和action。
 */</span>
<span class="comment">//  用KVC取出target和action</span>
<span class="built_in">NSArray</span> *internalTargets = [<span class="keyword">self</span><span class="variable">.interactivePopGestureRecognizer</span> valueForKey:<span class="string">@"targets"</span>];
<span class="keyword">id</span> internalTarget = [internalTargets<span class="variable">.firstObject</span> valueForKey:<span class="string">@"target"</span>];
SEL internalAction = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"handleNavigationTransition:"</span>);

<span class="comment">//  将自定义的代理（手势执行条件）传给手势的delegate</span>
<span class="keyword">self</span><span class="variable">.pda_popGestureRecognizer</span><span class="variable">.delegate</span> = <span class="keyword">self</span><span class="variable">.pda_popGestureRecognizerDelegate</span>;
<span class="comment">//  将target和action传给手势</span>
[<span class="keyword">self</span><span class="variable">.pda_popGestureRecognizer</span> addTarget:internalTarget action:internalAction];

<span class="comment">//  设置系统的为NO</span>
<span class="keyword">self</span><span class="variable">.interactivePopGestureRecognizer</span><span class="variable">.enabled</span> = <span class="literal">NO</span>;
</code></pre><p>  }<br>  //  执行原本的方法<br>  if (![self.viewControllers containsObject:viewController]) {</p>
<pre><code>[self <span class="string">pda_pushViewController:</span>viewController <span class="string">animated:</span>animated];
</code></pre><p>  }<br>}<br>其中要注意的是将前面定义的手势触发条件的delegate传给pda_popGestureRecognizer的delegate。</p>
</li>
</ul>
<p>最后补上pda_popGestureRecognizer的getter和pda_popGestureRecognizerDelegate的setter方法。</p>
<ul>
<li><p>(PDAFullscreenPopGestureRecognizerDelegate <em>)pda_popGestureRecognizerDelegate<br>{<br>  PDAFullscreenPopGestureRecognizerDelegate </em>delegate = objc_getAssociatedObject(self, _cmd);<br>  if (!delegate) {</p>
<pre><code><span class="keyword">delegate</span> = [[PDAFullscreenPopGestureRecognizerDelegate alloc] init];
<span class="keyword">delegate</span>.navigationController = <span class="keyword">self</span>;
objc_setAssociatedObject(<span class="keyword">self</span>, _cmd, <span class="keyword">delegate</span>, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
</code></pre><p>  }<br>  return delegate;<br>}</p>
</li>
<li><p>(UIPanGestureRecognizer <em>)pda_fullscreenPopGestureRecognizer<br>{<br>  UIPanGestureRecognizer </em>panGestureRecognizer = objc_getAssociatedObject(self, _cmd);<br>  if (!panGestureRecognizer) {</p>
<pre><code>panGestureRecognizer = [[UIPanGestureRecognizer alloc] init]<span class="comment">;</span>
panGestureRecognizer.maximumNumberOfTouches = 1<span class="comment">;</span>
objc_setAssociatedObject(self, _cmd, panGestureRecognizer, OBJC_ASSOCIATION_RETAIN_NONATOMIC)<span class="comment">;</span>
</code></pre><p>  }<br>  return panGestureRecognizer;<br>}<br>后面UIViewController只需要给出pda_interactivePopMaxAllowedInitialDistanceToLeftEdge和pda_interactivePopDisabled的setter和getter即可。</p>
</li>
</ul>
<p>后记</p>
<p>大功告成，直接添加到工程里，不用额外代码即可为你的项目添加滑动返回效果，快去试试吧！</p>
<p>参考链接</p>
<p><a href="http://blog.devtang.com/blog/2013/10/15/objective-c-object-model/" target="_blank" rel="external">http://blog.devtang.com/blog/2013/10/15/objective-c-object-model/</a></p>
<p><a href="http://blog.sina.com.cn/s/blog_65c178a80102v0f4.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_65c178a80102v0f4.html</a></p>
<p><a href="http://www.cocoachina.com/ios/20150120/10959.html" target="_blank" rel="external">http://www.cocoachina.com/ios/20150120/10959.html</a></p>
<p><a href="http://www.jianshu.com/p/d39f7d22db6c" target="_blank" rel="external">http://www.jianshu.com/p/d39f7d22db6c</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前言</p>
<p>从iOS7开始，苹果增加了页面右滑返回的效果，具体的是以UINavigationController为容器的ViewController间右滑切换页面。</p>
<p>代码里的设置是：</p>
<p>self.navigationController.i]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS开发Tips]]></title>
    <link href="http://v2panda.com/2015/07/27/iOS%E5%BC%80%E5%8F%91Tips/"/>
    <id>http://v2panda.com/2015/07/27/iOS开发Tips/</id>
    <published>2015-07-27T08:44:49.000Z</published>
    <updated>2015-10-19T10:49:45.000Z</updated>
    <content type="html"><![CDATA[<p>以上是摘要</p>
<a id="more"></a>
<h3 id="介绍">介绍</h3><p>随着开发的进行，用到的一些小技巧和插件工具也越来越多。在这里统一的总结一下，方便查阅，时时更新。</p>
<h5 id="小技巧">小技巧</h5><ul>
<li>一个 GCC 非常模糊的特性，以及 Clang 也有的特性是，代码块如果在闭合的圆括号内的话，会返回最后语句的值。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *url = (&#123; </span><br><span class="line">    <span class="built_in">NSString</span> *urlString = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@/%@"</span>, baseURLString, endpoint]; </span><br><span class="line">    [<span class="built_in">NSURL</span> URLWithString:urlString];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这个特性非常适合组织小块的代码，通常是设置一个类。给出一个重要的入口并且减少相关干扰，能让代码聚焦于关键的变量和函数中。此外，这个方法有一个优点，所有的变量都在代码块中，也就是只在代码块的区域中有效，这意味着可以减少对其他作用域的命名污染。</p>
<ul>
<li>在 Block 内如果需要访问 self 的方法、变量，建议使用 weakSelf。<br>如果在 Block 内需要多次 访问 self，则需要使用 strongSelf。</li>
</ul>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">__weak __typeof__<span class="list">(<span class="keyword">self</span>)</span> weakSelf = self<span class="comment">;</span></span><br><span class="line"> dispatch_async<span class="list">(<span class="keyword">dispatch_get_global_queue</span><span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span>, ^&#123;</span><br><span class="line">    __strong __typeof<span class="list">(<span class="keyword">self</span>)</span> strongSelf = weakSelf<span class="comment">;</span></span><br><span class="line">    if <span class="list">(<span class="keyword">strongSelf</span>)</span> &#123; </span><br><span class="line">     [strongSelf doSomething]<span class="comment">; </span></span><br><span class="line">     [strongSelf doSomethingElse]<span class="comment">; </span></span><br><span class="line">    &#125; else &#123; </span><br><span class="line">     // Probably nothing... return<span class="comment">; </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>在 doSomething 中，weakSelf 不会变成 nil，不过在 doSomething 执行完成，调用第二个方法 doOtherThing 的时候，weakSelf 有可能被释放。即在没有循环引用的时候，block 是否被 retain 或者是一个属性都没关系。如果 block 被传递或者 copy 了，在执行的时候，weakSelf 可能会变成 nil。于是，strongSelf 就派上用场了,而__strong确保在 Block 内，strongSelf 不会被释放。</p>
<h5 id="Xcode插件">Xcode插件</h5><p>1.<a href="https://github.com/omz/ColorSense-for-Xcode" target="_blank" rel="external">ColorSense for Xcode</a> - 用UIColor或者 NSColor的方法会弹出色盘和颜色角标，赞！</p>
<p>2.<a href="https://github.com/markohlebar/Peckham" target="_blank" rel="external">Peckham</a> - 能十分方便的在代码中引入头文件,支持模糊搜索，快捷键control+command+p。</p>
<p>3.<a href="https://github.com/stefanceriu/SCXcodeMiniMap" target="_blank" rel="external">SCXcodeMinimap</a> - 可以再代码侧面添加一个小地图，方便搜索的时候快速定位，快捷键control+shift+m。</p>
<p>4.<a href="https://github.com/trawor/XToDo" target="_blank" rel="external">XToDo</a> - 快速添加todo list(view -&gt;snippets),且能精确查找todo，快捷键control+t。</p>
<p>5.<a href="https://github.com/onevcat/VVDocumenter-Xcode" target="_blank" rel="external">VVDocumenter</a> - 快速注释，快捷键///。</p>
<p>6.<a href="https://github.com/ksuther/KSImageNamed-Xcode" target="_blank" rel="external">KSImageNamed</a> - 自动在 imageNamed:方法后面列出项目里所有的文件名，带缩略图。</p>
<p>7.<a href="https://github.com/holtwick/HOStringSense-for-Xcode" target="_blank" rel="external">HOStringSense</a> - 格式化字符串，方便好用。</p>
<p>8.<a href="https://github.com/FuzzyAutocomplete/FuzzyAutocompletePlugin" target="_blank" rel="external">FuzzyAutocompletePlugin</a> - 方法名模糊匹配，提高效率的好工具。</p>
<p>9.<a href="https://github.com/travisjeffery/ClangFormat-Xcode" target="_blank" rel="external">ClangFormat-Xcode</a> - 一键格式化代码。</p>
<h5 id="几种处理JSON的工具or网站">几种处理JSON的工具or网站</h5><p><a href="http://www.bejson.com/" target="_blank" rel="external">JSON校验</a><br><a href="http://www.runoob.com/tool/json/index.html" target="_blank" rel="external">JSON格式化工具</a><br><a href="http://www.jsoneditoronline.org/" target="_blank" rel="external">json editor online</a></p>
<h5 id="图片压缩">图片压缩</h5><p><a href="https://tinypng.com/" target="_blank" rel="external">tinypng</a> - 无损压缩，高效好用。</p>
<h5 id="调试接口">调试接口</h5><p>Postman(chrome插件 - 见图)<br><img src="http://7xnmlk.com1.z0.glb.clouddn.com/20150727/a.png" alt="Postman"></p>
<h5 id="注释">注释</h5><p>几种常用的注释样式：</p>
<p>1.<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span> ,<span class="keyword">strong</span>) RHBankCard *bankCard;<span class="comment">/**&lt;银行卡信息*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span> ,<span class="keyword">strong</span>) RHBankCard *bankCard;<span class="comment">///&lt;银行卡信息</span></span><br></pre></td></tr></table></figure></p>
<p>2.<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span><span class="keyword">*</span>银行卡信息<span class="keyword">*</span>/</span><br><span class="line"><span class="comment">@property (nonatomic ,strong) RHBankCard *bankCard;</span></span><br></pre></td></tr></table></figure></p>
<p>3.<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="class"><span class="keyword">enum</span></span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="constant">ShareTypeSinaWeibo</span> = <span class="number">1</span>,         <span class="regexp">/**&lt; 新浪微博 */</span></span><br><span class="line"> <span class="constant">ShareTypeTencentWeibo</span> = <span class="number">2</span>,      <span class="regexp">/**&lt; 腾讯微博 */</span></span><br><span class="line"> <span class="constant">ShareTypeDouBan</span> = <span class="number">5</span>,            <span class="regexp">/**&lt; 豆瓣社区 */</span></span><br><span class="line"> <span class="constant">ShareTypeQQSpace</span> = <span class="number">6</span>,           <span class="regexp">/**&lt; QQ空间 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="constant">ShareType</span>;</span><br></pre></td></tr></table></figure></p>
<p>4.</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span>  initWithStyle</span><br><span class="line"> <span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span>  <span class="comment">@param style           style description</span></span><br><span class="line"> <span class="keyword">*</span>  <span class="comment">@param reuseIdentifier reuseIdentifier description</span></span><br><span class="line"> <span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span>  <span class="comment">@return self</span></span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">- (id)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString <span class="keyword">*</span>)reuseIdentifier;</span><br></pre></td></tr></table></figure>
<p>前两种注释方式可以自由选择，让代码更美观。第三种是用在enum类型，第四种用的是喵神的<a href="https://github.com/onevcat/VVDocumenter-Xcode" target="_blank" rel="external">VVDocumenter</a>插件，适用于param多的方法。</p>
<h5 id="正确地定义常量">正确地定义常量</h5><p>以前定义常量都是用的#define，很简单也方便，从没想过可能出现的问题。一般这么定义：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hexcolor">#def</span>ine ANIMATION_DURATION_SHORT <span class="number">0.3</span></span><br><span class="line"><span class="hexcolor">#def</span>ine ANIMATION_DURATION_MIDDLE <span class="number">0.6</span></span><br><span class="line"><span class="hexcolor">#def</span>ine ANIMATION_DURATION_LONG <span class="number">1.0</span></span><br></pre></td></tr></table></figure>
<p>这段代码是不是看起来很熟悉，在开发中也会经常用到。那么问题来了，宏定义只是简单地替换，即将一切宏定义替换成定义后面的内容，所以</p>
<ul>
<li>宏定义不会检查替换的“<strong>类型</strong>”，只要遇到，就做替换。</li>
<li>宏定义不保证“<strong>不可变</strong>”，因为可以<strong>重复定义</strong>，不能保证值不变。</li>
</ul>
<p>所以，恰当的常量应该具备合适的名字、正确的类型，还有const、extern等关键字的修饰。例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动画时间长度常量 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> NSTimeInterval kAnimationDurationLong = <span class="number">1.0f</span>;</span><br></pre></td></tr></table></figure>
<p>首先加static，限定在本文件中使用，确保不与其他的常量冲突，其次加const确保常量不被改变。若要定义一个全局变量，则在.h文件中用extern声明，在.m中定义，这样:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> PDUserInfoNotification;</span><br><span class="line"><span class="comment">//.m</span></span><br><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> PDUserInfoNotification = <span class="string">@"PDUserInfoNotification"</span>;</span><br></pre></td></tr></table></figure>
<p>关于这点，更详细的可以看<a href="http://tutuge.me/2015/03/11/Effective-Objective-C-读书笔记-Item-4-如何正确定义常量/" target="_blank" rel="external">这里</a>。</p>
<h5 id="CGRect函数">CGRect函数</h5><p>当访问CGRect里的x, y, width, 或 height时，应该使用<a href="http://developer.apple.com/library/ios/#documentation/graphicsimaging/reference/CGGeometry/Reference/reference.html" target="_blank" rel="external">CGGeometry函数</a>而不是直接通过结构体来访问。引用Apple的CGGeometry:在这个参考文档中所有的函数，接受CGRect结构体作为输入，在计算它们结果时隐式地标准化这些rectangles。因此，你的应用程序应该避免直接访问和修改保存在CGRect数据结构中的数据。相反，使用这些函数来操纵rectangles和获取它们的特性。</p>
<p><strong>应该:</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGRect</span> frame = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.frame</span>;</span><br><span class="line"><span class="built_in">CGFloat</span> x = <span class="built_in">CGRectGetMinX</span>(frame);</span><br><span class="line"><span class="built_in">CGFloat</span> y = <span class="built_in">CGRectGetMinY</span>(frame);</span><br><span class="line"><span class="built_in">CGFloat</span> width = <span class="built_in">CGRectGetWidth</span>(frame);</span><br><span class="line"><span class="built_in">CGFloat</span> height = <span class="built_in">CGRectGetHeight</span>(frame);</span><br><span class="line"><span class="built_in">CGRect</span> frame = <span class="built_in">CGRectMake</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, width, height);</span><br></pre></td></tr></table></figure>
<p><strong>不应该:</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGRect</span> frame = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.frame</span>;</span><br><span class="line"><span class="built_in">CGFloat</span> x = frame<span class="variable">.origin</span><span class="variable">.x</span>;</span><br><span class="line"><span class="built_in">CGFloat</span> y = frame<span class="variable">.origin</span><span class="variable">.y</span>;</span><br><span class="line"><span class="built_in">CGFloat</span> width = frame<span class="variable">.size</span><span class="variable">.width</span>;</span><br><span class="line"><span class="built_in">CGFloat</span> height = frame<span class="variable">.size</span><span class="variable">.height</span>;</span><br><span class="line"><span class="built_in">CGRect</span> frame = (<span class="built_in">CGRect</span>)&#123; <span class="variable">.origin</span> = <span class="built_in">CGPointZero</span>, <span class="variable">.size</span> = frame<span class="variable">.size</span> &#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p><a href="https://github.com/samlaudev/Objective-C-Coding-Style#黄金路径" target="_blank" rel="external"></a></p>
<h5 id="黄金路径">黄金路径</h5><p>当使用条件语句编码时，左手边的代码应该是”golden” 或 “happy”路径。也就是不要嵌套if<br>语句，多个返回语句也是OK。<br><strong>应该:</strong></p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)someMethod &#123; </span><br><span class="line">  <span class="keyword">if</span> (![someOther boolValue])</span><br><span class="line">   &#123; </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">   &#125; </span><br><span class="line">  <span class="comment">//Do something important</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>不应该:</strong></p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (void)<span class="tag">someMethod</span> &#123;</span><br><span class="line"> <span class="tag">if</span> ([someOther boolValue]) </span><br><span class="line">   &#123; </span><br><span class="line">    <span class="comment">//Do something important</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>以上是摘要</p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://v2panda.com/tags/iOS/"/>
    
  </entry>
  
</feed>
